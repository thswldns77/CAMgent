{"version":3,"file":"ChatGptTypeChecker.mjs","sources":["../../src/utils/ChatGptTypeChecker.ts"],"sourcesContent":["import { IChatGptSchema } from \"../structures/IChatGptSchema\";\nimport { MapUtil } from \"./MapUtil\";\n\n/**\n * Type checker for ChatGPT type schema.\n *\n * `ChatGptTypeChecker` is a type checker of {@link IChatGptSchema}.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport namespace ChatGptTypeChecker {\n  /* -----------------------------------------------------------\n    TYPE CHECKERS\n  ----------------------------------------------------------- */\n  /**\n   * Test whether the schema is a null type.\n   *\n   * @param schema Target schema\n   * @returns Whether null type or not\n   */\n  export const isNull = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.INull =>\n    (schema as IChatGptSchema.INull).type === \"null\";\n\n  /**\n   * Test whether the schema is an unknown type.\n   *\n   * @param schema Target schema\n   * @returns Whether unknown type or not\n   */\n  export const isUnknown = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IUnknown =>\n    (schema as IChatGptSchema.IUnknown).type === undefined &&\n    !isAnyOf(schema) &&\n    !isReference(schema);\n\n  /**\n   * Test whether the schema is a boolean type.\n   *\n   * @param schema Target schema\n   * @returns Whether boolean type or not\n   */\n  export const isBoolean = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IBoolean =>\n    (schema as IChatGptSchema.IBoolean).type === \"boolean\";\n\n  /**\n   * Test whether the schema is an integer type.\n   *\n   * @param schema Target schema\n   * @returns Whether integer type or not\n   */\n  export const isInteger = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IInteger =>\n    (schema as IChatGptSchema.IInteger).type === \"integer\";\n\n  /**\n   * Test whether the schema is a number type.\n   *\n   * @param schema Target schema\n   * @returns Whether number type or not\n   */\n  export const isNumber = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.INumber =>\n    (schema as IChatGptSchema.INumber).type === \"number\";\n\n  /**\n   * Test whether the schema is a string type.\n   *\n   * @param schema Target schema\n   * @returns Whether string type or not\n   */\n  export const isString = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IString =>\n    (schema as IChatGptSchema.IString).type === \"string\";\n\n  /**\n   * Test whether the schema is an array type.\n   *\n   * @param schema Target schema\n   * @returns Whether array type or not\n   */\n  export const isArray = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IArray =>\n    (schema as IChatGptSchema.IArray).type === \"array\" &&\n    (schema as IChatGptSchema.IArray).items !== undefined;\n\n  /**\n   * Test whether the schema is an object type.\n   *\n   * @param schema Target schema\n   * @returns Whether object type or not\n   */\n  export const isObject = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IObject =>\n    (schema as IChatGptSchema.IObject).type === \"object\";\n\n  /**\n   * Test whether the schema is a reference type.\n   *\n   * @param schema Target schema\n   * @returns Whether reference type or not\n   */\n  export const isReference = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IReference => (schema as any).$ref !== undefined;\n\n  /**\n   * Test whether the schema is an union type.\n   *\n   * @param schema Target schema\n   * @returns Whether union type or not\n   */\n  export const isAnyOf = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IAnyOf =>\n    (schema as IChatGptSchema.IAnyOf).anyOf !== undefined;\n\n  /* -----------------------------------------------------------\n    OPERATORS\n  ----------------------------------------------------------- */\n  /**\n   * Visit every nested schemas.\n   *\n   * Visit every nested schemas of the target, and apply the `props.closure`\n   * function.\n   *\n   * Here is the list of occurring nested visitings:\n   *\n   * - {@link IChatGptSchema.IAnyOf.anyOf}\n   * - {@link IChatGptSchema.IReference}\n   * - {@link IChatGptSchema.IObject.properties}\n   * - {@link IChatGptSchema.IArray.items}\n   *\n   * @param props Properties for visiting\n   */\n  export const visit = (props: {\n    closure: (schema: IChatGptSchema, accessor: string) => void;\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    schema: IChatGptSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): void => {\n    const already: Set<string> = new Set();\n    const refAccessor: string = props.refAccessor ?? \"$input.$defs\";\n    const next = (schema: IChatGptSchema, accessor: string): void => {\n      props.closure(schema, accessor);\n      if (ChatGptTypeChecker.isReference(schema)) {\n        const key: string = schema.$ref.split(\"#/$defs/\").pop()!;\n        if (already.has(key) === true) return;\n        already.add(key);\n        const found: IChatGptSchema | undefined = props.$defs?.[key];\n        if (found !== undefined) next(found, `${refAccessor}[${key}]`);\n      } else if (ChatGptTypeChecker.isAnyOf(schema))\n        schema.anyOf.forEach((s, i) => next(s, `${accessor}.anyOf[${i}]`));\n      else if (ChatGptTypeChecker.isObject(schema)) {\n        for (const [key, value] of Object.entries(schema.properties))\n          next(value, `${accessor}.properties[${JSON.stringify(key)}]`);\n        if (\n          typeof schema.additionalProperties === \"object\" &&\n          schema.additionalProperties !== null\n        )\n          next(schema.additionalProperties, `${accessor}.additionalProperties`);\n      } else if (ChatGptTypeChecker.isArray(schema))\n        next(schema.items, `${accessor}.items`);\n    };\n    next(props.schema, props.accessor ?? \"$input.schemas\");\n  };\n\n  /**\n   * Test whether the `x` schema covers the `y` schema.\n   *\n   * @param props Properties for testing\n   * @returns Whether the `x` schema covers the `y` schema\n   */\n  export const covers = (props: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    x: IChatGptSchema;\n    y: IChatGptSchema;\n  }): boolean =>\n    coverStation({\n      $defs: props.$defs,\n      x: props.x,\n      y: props.y,\n      visited: new Map(),\n    });\n\n  const coverStation = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema;\n    y: IChatGptSchema;\n  }): boolean => {\n    const cache: boolean | undefined = p.visited.get(p.x)?.get(p.y);\n    if (cache !== undefined) return cache;\n\n    // FOR RECURSIVE CASE\n    const nested: Map<IChatGptSchema, boolean> = MapUtil.take(p.visited)(p.x)(\n      () => new Map(),\n    );\n    nested.set(p.y, true);\n\n    // COMPUTE IT\n    const result: boolean = coverSchema(p);\n    nested.set(p.y, result);\n    return result;\n  };\n\n  const coverSchema = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema;\n    y: IChatGptSchema;\n  }): boolean => {\n    // CHECK EQUALITY\n    if (p.x === p.y) return true;\n    else if (isReference(p.x) && isReference(p.y) && p.x.$ref === p.y.$ref)\n      return true;\n\n    // COMPARE WITH FLATTENING\n    const alpha: IChatGptSchema[] = flatSchema(p.$defs, p.x);\n    const beta: IChatGptSchema[] = flatSchema(p.$defs, p.y);\n    if (alpha.some((x) => isUnknown(x))) return true;\n    else if (beta.some((x) => isUnknown(x))) return false;\n    return beta.every((b) =>\n      alpha.some((a) =>\n        coverEscapedSchema({\n          $defs: p.$defs,\n          visited: p.visited,\n          x: a,\n          y: b,\n        }),\n      ),\n    );\n  };\n\n  const coverEscapedSchema = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema;\n    y: IChatGptSchema;\n  }): boolean => {\n    // CHECK EQUALITY\n    if (p.x === p.y) return true;\n    else if (isUnknown(p.x)) return true;\n    else if (isUnknown(p.y)) return false;\n    else if (isNull(p.x)) return isNull(p.y);\n    // ATOMIC CASE\n    else if (isBoolean(p.x)) return isBoolean(p.y) && coverBoolean(p.x, p.y);\n    else if (isInteger(p.x)) return isInteger(p.y) && coverInteger(p.x, p.y);\n    else if (isNumber(p.x)) return isNumber(p.y) && coverNumber(p.x, p.y);\n    else if (isString(p.x)) return isString(p.y) && coverString(p.x, p.y);\n    // INSTANCE CASE\n    else if (isArray(p.x))\n      return (\n        isArray(p.y) &&\n        coverArray({\n          $defs: p.$defs,\n          visited: p.visited,\n          x: p.x,\n          y: p.y,\n        })\n      );\n    else if (isObject(p.x))\n      return (\n        isObject(p.y) &&\n        coverObject({\n          $defs: p.$defs,\n          visited: p.visited,\n          x: p.x,\n          y: p.y,\n        })\n      );\n    else if (isReference(p.x)) return isReference(p.y) && p.x.$ref === p.y.$ref;\n    return false;\n  };\n\n  const coverArray = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema.IArray;\n    y: IChatGptSchema.IArray;\n  }): boolean =>\n    coverStation({\n      $defs: p.$defs,\n      visited: p.visited,\n      x: p.x.items,\n      y: p.y.items,\n    });\n\n  const coverObject = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema.IObject;\n    y: IChatGptSchema.IObject;\n  }): boolean => {\n    if (!p.x.additionalProperties && !!p.y.additionalProperties) return false;\n    else if (\n      !!p.x.additionalProperties &&\n      !!p.y.additionalProperties &&\n      ((typeof p.x.additionalProperties === \"object\" &&\n        p.y.additionalProperties === true) ||\n        (typeof p.x.additionalProperties === \"object\" &&\n          typeof p.y.additionalProperties === \"object\" &&\n          !coverStation({\n            $defs: p.$defs,\n            visited: p.visited,\n            x: p.x.additionalProperties,\n            y: p.y.additionalProperties,\n          })))\n    )\n      return false;\n    return Object.entries(p.y.properties ?? {}).every(([key, b]) => {\n      const a: IChatGptSchema | undefined = p.x.properties?.[key];\n      if (a === undefined) return false;\n      else if (\n        (p.x.required?.includes(key) ?? false) === true &&\n        (p.y.required?.includes(key) ?? false) === false\n      )\n        return false;\n      return coverStation({\n        $defs: p.$defs,\n        visited: p.visited,\n        x: a,\n        y: b,\n      });\n    });\n  };\n\n  const coverBoolean = (\n    x: IChatGptSchema.IBoolean,\n    y: IChatGptSchema.IBoolean,\n  ): boolean => {\n    if (!!x.enum?.length)\n      return !!y.enum?.length && y.enum.every((v) => x.enum!.includes(v));\n    return true;\n  };\n\n  const coverInteger = (\n    x: IChatGptSchema.IInteger,\n    y: IChatGptSchema.IInteger,\n  ): boolean => {\n    if (!!x.enum?.length)\n      return !!y.enum?.length && y.enum.every((v) => x.enum!.includes(v));\n    return x.type === y.type;\n  };\n\n  const coverNumber = (\n    x: IChatGptSchema.INumber,\n    y: IChatGptSchema.IInteger | IChatGptSchema.INumber,\n  ): boolean => {\n    if (!!x.enum?.length)\n      return !!y.enum?.length && y.enum.every((v) => x.enum!.includes(v));\n    return x.type === y.type || (x.type === \"number\" && y.type === \"integer\");\n  };\n\n  const coverString = (\n    x: IChatGptSchema.IString,\n    y: IChatGptSchema.IString,\n  ): boolean => {\n    if (!!x.enum?.length)\n      return !!y.enum?.length && y.enum.every((v) => x.enum!.includes(v));\n    return x.type === y.type;\n  };\n\n  const flatSchema = (\n    $defs: Record<string, IChatGptSchema> | undefined,\n    schema: IChatGptSchema,\n  ): IChatGptSchema[] => {\n    schema = escapeReference($defs, schema);\n    if (isAnyOf(schema))\n      return schema.anyOf.map((v) => flatSchema($defs, v)).flat();\n    return [schema];\n  };\n\n  const escapeReference = (\n    $defs: Record<string, IChatGptSchema> | undefined,\n    schema: IChatGptSchema,\n  ): Exclude<IChatGptSchema, IChatGptSchema.IReference> =>\n    isReference(schema)\n      ? escapeReference($defs, $defs![schema.$ref.replace(\"#/$defs/\", \"\")]!)\n      : schema;\n}\n"],"names":["ChatGptTypeChecker","isNull","schema","type","isUnknown","undefined","isAnyOf","isReference","isBoolean","isInteger","isNumber","isString","isArray","items","isObject","$ref","anyOf","visit","props","already","Set","refAccessor","next","accessor","closure","key","split","pop","has","add","found","$defs","forEach","s","i","value","Object","entries","properties","JSON","stringify","additionalProperties","covers","coverStation","x","y","visited","Map","p","cache","get","nested","MapUtil","take","set","result","coverSchema","alpha","flatSchema","beta","some","every","b","a","coverEscapedSchema","coverBoolean","coverInteger","coverNumber","coverString","coverArray","coverObject","required","includes","enum","length","v","escapeReference","map","flat","replace"],"mappings":"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"}