{"version":3,"file":"LlmDataMerger.mjs","sources":["../../src/utils/LlmDataMerger.ts"],"sourcesContent":["import { ILlmFunction } from \"../structures/ILlmFunction\";\nimport { ILlmSchema } from \"../structures/ILlmSchema\";\n\n/**\n * Data combiner for LLM function call.\n *\n * @author Samchon\n */\nexport namespace LlmDataMerger {\n  /** Properties of {@link parameters} function. */\n  export interface IProps<Model extends ILlmSchema.Model> {\n    /** Target function to call. */\n    function: ILlmFunction<Model>;\n\n    /** Arguments composed by LLM (Large Language Model). */\n    llm: object | null;\n\n    /** Arguments composed by human. */\n    human: object | null;\n  }\n\n  /**\n   * Combine LLM and human arguments into one.\n   *\n   * When you composes {@link IOpenAiDocument} with\n   * {@link IOpenAiDocument.IOptions.separate} option, then the arguments of the\n   * target function would be separated into two parts; LLM (Large Language\n   * Model) and human.\n   *\n   * In that case, you can combine both LLM and human composed arguments into\n   * one by utilizing this {@link LlmDataMerger.parameters} function, referencing\n   * the target function metadata {@link IOpenAiFunction.separated}.\n   *\n   * @param props Properties to combine LLM and human arguments with metadata.\n   * @returns Combined arguments\n   */\n  export const parameters = <Model extends ILlmSchema.Model>(\n    props: IProps<Model>,\n  ): object => {\n    const separated = props.function.separated;\n    if (separated === undefined)\n      throw new Error(\n        \"Error on OpenAiDataComposer.parameters(): the function parameters are not separated.\",\n      );\n    return value(props.llm, props.human) as object;\n  };\n\n  /**\n   * Combine two values into one.\n   *\n   * If both values are objects, then combines them in the properties level.\n   *\n   * Otherwise, returns the latter value if it's not null, otherwise the former\n   * value\n   *\n   * - `return (y ?? x)`\n   *\n   * @param x Value X\n   * @param y Value Y\n   * @returns Combined value\n   */\n  export const value = (x: unknown, y: unknown): unknown =>\n    typeof x === \"object\" && typeof y === \"object\" && x !== null && y !== null\n      ? combineObject(x, y)\n      : Array.isArray(x) && Array.isArray(y)\n        ? new Array(Math.max(x.length, y.length))\n            .fill(0)\n            .map((_, i) => value(x[i], y[i]))\n        : (y ?? x);\n\n  const combineObject = (x: any, y: any): any => {\n    const output: any = { ...x };\n    for (const [k, v] of Object.entries(y)) output[k] = value(x[k], v);\n    return output;\n  };\n}\n"],"names":["LlmDataMerger","parameters","props","separated","function","undefined","Error","value","llm","human","x","y","combineObject","Array","isArray","Math","max","length","fill","map","_","i","output","k","v","Object","entries"],"mappings":"AAQM,IAAWA;;CAAjB,SAAiBA;IA4BFA,cAAAC,aACXC;QAEA,MAAMC,YAAYD,MAAME,SAASD;QACjC,IAAIA,cAAcE,WAChB,MAAM,IAAIC,MACR;QAEJ,OAAON,cAAAO,MAAML,MAAMM,KAAKN,MAAMO;AAAgB;IAiBnCT,cAAKO,QAAG,CAACG,GAAYC,aACzBD,MAAM,mBAAmBC,MAAM,YAAYD,MAAM,QAAQC,MAAM,OAClEC,cAAcF,GAAGC,KACjBE,MAAMC,QAAQJ,MAAMG,MAAMC,QAAQH,KAChC,IAAIE,MAAME,KAAKC,IAAIN,EAAEO,QAAQN,EAAEM,SAC5BC,KAAK,GACLC,KAAI,CAACC,GAAGC,MAAMrB,cAAAO,MAAMG,EAAEW,IAAIV,EAAEU,QAC9BV,KAAKD;IAEd,MAAME,gBAAgB,CAACF,GAAQC;QAC7B,MAAMW,SAAc;eAAKZ;;QACzB,KAAK,OAAOa,GAAGC,MAAMC,OAAOC,QAAQf,IAAIW,OAAOC,KAAKvB,cAAAO,MAAMG,EAAEa,IAAIC;QAChE,OAAOF;AAAM;AAEhB,EAnED,CAAiBtB,kBAAAA,gBAmEhB,CAAA;;"}