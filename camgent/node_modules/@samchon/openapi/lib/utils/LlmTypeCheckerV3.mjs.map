{"version":3,"file":"LlmTypeCheckerV3.mjs","sources":["../../src/utils/LlmTypeCheckerV3.ts"],"sourcesContent":["import { ILlmSchemaV3 } from \"../structures/ILlmSchemaV3\";\nimport { OpenApiTypeCheckerBase } from \"./internal/OpenApiTypeCheckerBase\";\n\n/**\n * Type checker for LLM type schema v3.\n *\n * `LlmTypeCheckerV3` is a type checker of {@link ILlmSchemaV3}.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport namespace LlmTypeCheckerV3 {\n  /* -----------------------------------------------------------\n    OPERATORS\n  ----------------------------------------------------------- */\n  /**\n   * Visit every nested schemas.\n   *\n   * Visit every nested schemas of the target, and apply the `props.closure`\n   * function.\n   *\n   * Here is the list of occurring nested visitings:\n   *\n   * - {@link ILlmSchemaV3.IOneOf.oneOf}\n   * - {@link ILlmSchemaV3.IObject.additionalProperties}\n   * - {@link ILlmSchemaV3.IArray.items}\n   *\n   * @param props Properties for visiting\n   */\n  export const visit = (props: {\n    closure: (schema: ILlmSchemaV3, accessor: string) => void;\n    schema: ILlmSchemaV3;\n    accessor?: string;\n  }): void => {\n    const accessor: string = props.accessor ?? \"$input.schema\";\n    props.closure(props.schema, accessor);\n    if (isOneOf(props.schema))\n      props.schema.oneOf.forEach((s, i) =>\n        visit({\n          closure: props.closure,\n          schema: s,\n          accessor: `${accessor}.oneOf[${i}]`,\n        }),\n      );\n    else if (isObject(props.schema)) {\n      for (const [k, s] of Object.entries(props.schema.properties))\n        visit({\n          closure: props.closure,\n          schema: s,\n          accessor: `${accessor}.properties[${JSON.stringify(k)}]`,\n        });\n      if (\n        typeof props.schema.additionalProperties === \"object\" &&\n        props.schema.additionalProperties !== null\n      )\n        visit({\n          closure: props.closure,\n          schema: props.schema.additionalProperties,\n          accessor: `${accessor}.additionalProperties`,\n        });\n    } else if (isArray(props.schema))\n      visit({\n        closure: props.closure,\n        schema: props.schema.items,\n        accessor: `${accessor}.items`,\n      });\n  };\n\n  export const covers = (x: ILlmSchemaV3, y: ILlmSchemaV3): boolean => {\n    const alpha: ILlmSchemaV3[] = flatSchema(x);\n    const beta: ILlmSchemaV3[] = flatSchema(y);\n    if (alpha.some((x) => isUnknown(x))) return true;\n    else if (beta.some((x) => isUnknown(x))) return false;\n    return beta.every((b) =>\n      alpha.some((a) => {\n        // CHECK EQUALITY\n        if (a === b) return true;\n        else if (isUnknown(a)) return true;\n        else if (isUnknown(b)) return false;\n        else if (isNullOnly(a)) return isNullOnly(b);\n        else if (isNullOnly(b)) return isNullable(a);\n        else if (isNullable(a) && !isNullable(b)) return false;\n        // ATOMIC CASE\n        else if (isBoolean(a)) return isBoolean(b) && coverBoolean(a, b);\n        else if (isInteger(a)) return isInteger(b) && coverInteger(a, b);\n        else if (isNumber(a))\n          return (isNumber(b) || isInteger(b)) && coverNumber(a, b);\n        else if (isString(a)) return isString(b) && covertString(a, b);\n        // INSTANCE CASE\n        else if (isArray(a)) return isArray(b) && coverArray(a, b);\n        else if (isObject(a)) return isObject(b) && coverObject(a, b);\n        else if (isOneOf(a)) return false;\n      }),\n    );\n  };\n\n  /** @internal */\n  const coverBoolean = (\n    x: ILlmSchemaV3.IBoolean,\n    y: ILlmSchemaV3.IBoolean,\n  ): boolean =>\n    x.enum === undefined ||\n    (y.enum !== undefined && x.enum.every((v) => y.enum!.includes(v)));\n\n  /** @internal */\n  const coverInteger = (\n    x: ILlmSchemaV3.IInteger,\n    y: ILlmSchemaV3.IInteger,\n  ): boolean => {\n    if (x.enum !== undefined)\n      return y.enum !== undefined && x.enum.every((v) => y.enum!.includes(v));\n    return x.type === y.type && OpenApiTypeCheckerBase.coverNumericRange(x, y);\n  };\n\n  /** @internal */\n  const coverNumber = (\n    x: ILlmSchemaV3.INumber,\n    y: ILlmSchemaV3.INumber | ILlmSchemaV3.IInteger,\n  ): boolean => {\n    if (x.enum !== undefined)\n      return y.enum !== undefined && x.enum.every((v) => y.enum!.includes(v));\n    return (\n      (x.type === y.type || (x.type === \"number\" && y.type === \"integer\")) &&\n      OpenApiTypeCheckerBase.coverNumericRange(x, y)\n    );\n  };\n\n  /** @internal */\n  const covertString = (\n    x: ILlmSchemaV3.IString,\n    y: ILlmSchemaV3.IString,\n  ): boolean => {\n    if (x.enum !== undefined)\n      return y.enum !== undefined && x.enum.every((v) => y.enum!.includes(v));\n    return [\n      x.type === y.type,\n      x.format === undefined ||\n        (y.format !== undefined && coverFormat(x.format, y.format)),\n      x.pattern === undefined || x.pattern === y.pattern,\n      x.minLength === undefined ||\n        (y.minLength !== undefined && x.minLength <= y.minLength),\n      x.maxLength === undefined ||\n        (y.maxLength !== undefined && x.maxLength >= y.maxLength),\n    ].every((v) => v);\n  };\n\n  const coverFormat = (\n    x: Required<ILlmSchemaV3.IString>[\"format\"],\n    y: Required<ILlmSchemaV3.IString>[\"format\"],\n  ): boolean =>\n    x === y ||\n    (x === \"idn-email\" && y === \"email\") ||\n    (x === \"idn-hostname\" && y === \"hostname\") ||\n    ([\"uri\", \"iri\"].includes(x) && y === \"url\") ||\n    (x === \"iri\" && y === \"uri\") ||\n    (x === \"iri-reference\" && y === \"uri-reference\");\n\n  /** @internal */\n  const coverArray = (\n    x: ILlmSchemaV3.IArray,\n    y: ILlmSchemaV3.IArray,\n  ): boolean => covers(x.items, y.items);\n\n  const coverObject = (\n    x: ILlmSchemaV3.IObject,\n    y: ILlmSchemaV3.IObject,\n  ): boolean => {\n    if (!x.additionalProperties && !!y.additionalProperties) return false;\n    else if (\n      (!!x.additionalProperties &&\n        !!y.additionalProperties &&\n        typeof x.additionalProperties === \"object\" &&\n        y.additionalProperties === true) ||\n      (typeof x.additionalProperties === \"object\" &&\n        typeof y.additionalProperties === \"object\" &&\n        !covers(x.additionalProperties, y.additionalProperties))\n    )\n      return false;\n    return Object.entries(y.properties ?? {}).every(([key, b]) => {\n      const a: ILlmSchemaV3 | undefined = x.properties?.[key];\n      if (a === undefined) return false;\n      else if (\n        (x.required?.includes(key) ?? false) === true &&\n        (y.required?.includes(key) ?? false) === false\n      )\n        return false;\n      return covers(a, b);\n    });\n  };\n\n  const flatSchema = (schema: ILlmSchemaV3): ILlmSchemaV3[] =>\n    isOneOf(schema) ? schema.oneOf.flatMap(flatSchema) : [schema];\n\n  /* -----------------------------------------------------------\n    TYPE CHECKERS\n  ----------------------------------------------------------- */\n  /**\n   * Test whether the schema is an union type.\n   *\n   * @param schema Target schema\n   * @returns Whether union type or not\n   */\n  export const isOneOf = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.IOneOf =>\n    (schema as ILlmSchemaV3.IOneOf).oneOf !== undefined;\n\n  /**\n   * Test whether the schema is an object type.\n   *\n   * @param schema Target schema\n   * @returns Whether object type or not\n   */\n  export const isObject = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.IObject =>\n    (schema as ILlmSchemaV3.IObject).type === \"object\";\n\n  /**\n   * Test whether the schema is an array type.\n   *\n   * @param schema Target schema\n   * @returns Whether array type or not\n   */\n  export const isArray = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.IArray =>\n    (schema as ILlmSchemaV3.IArray).type === \"array\";\n\n  /**\n   * Test whether the schema is a boolean type.\n   *\n   * @param schema Target schema\n   * @returns Whether boolean type or not\n   */\n  export const isBoolean = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.IBoolean =>\n    (schema as ILlmSchemaV3.IBoolean).type === \"boolean\";\n\n  /**\n   * Test whether the schema is an integer type.\n   *\n   * @param schema Target schema\n   * @returns Whether integer type or not\n   */\n  export const isInteger = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.IInteger =>\n    (schema as ILlmSchemaV3.IInteger).type === \"integer\";\n\n  /**\n   * Test whether the schema is a number type.\n   *\n   * @param schema Target schema\n   * @returns Whether number type or not\n   */\n  export const isNumber = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.INumber =>\n    (schema as ILlmSchemaV3.INumber).type === \"number\";\n\n  /**\n   * Test whether the schema is a string type.\n   *\n   * @param schema Target schema\n   * @returns Whether string type or not\n   */\n  export const isString = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.IString =>\n    (schema as ILlmSchemaV3.IString).type === \"string\";\n\n  /**\n   * Test whether the schema is a null type.\n   *\n   * @param schema Target schema\n   * @returns Whether null type or not\n   */\n  export const isNullOnly = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.INullOnly =>\n    (schema as ILlmSchemaV3.INullOnly).type === \"null\";\n\n  /**\n   * Test whether the schema is a nullable type.\n   *\n   * @param schema Target schema\n   * @returns Whether nullable type or not\n   */\n  export const isNullable = (schema: ILlmSchemaV3): boolean =>\n    !isUnknown(schema) &&\n    (isNullOnly(schema) ||\n      (isOneOf(schema)\n        ? schema.oneOf.some(isNullable)\n        : schema.nullable === true));\n\n  /**\n   * Test whether the schema is an unknown type.\n   *\n   * @param schema Target schema\n   * @returns Whether unknown type or not\n   */\n  export const isUnknown = (\n    schema: ILlmSchemaV3,\n  ): schema is ILlmSchemaV3.IUnknown =>\n    !isOneOf(schema) && (schema as ILlmSchemaV3.IUnknown).type === undefined;\n}\n"],"names":["LlmTypeCheckerV3","visit","props","accessor","closure","schema","isOneOf","oneOf","forEach","s","i","isObject","k","Object","entries","properties","JSON","stringify","additionalProperties","isArray","items","covers","x","y","alpha","flatSchema","beta","some","isUnknown","every","b","a","isNullOnly","isNullable","isBoolean","coverBoolean","isInteger","coverInteger","isNumber","coverNumber","isString","covertString","coverArray","coverObject","enum","undefined","v","includes","type","OpenApiTypeCheckerBase","coverNumericRange","format","coverFormat","pattern","minLength","maxLength","key","required","flatMap","nullable"],"mappings":"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"}