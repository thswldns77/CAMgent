{"version":3,"file":"OpenApiTypeCheckerBase.mjs","sources":["../../../src/utils/internal/OpenApiTypeCheckerBase.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../structures/IResult\";\nimport { AccessorUtil } from \"../AccessorUtil\";\nimport { MapUtil } from \"../MapUtil\";\nimport { JsonDescriptionUtil } from \"./JsonDescriptionUtil\";\n\n/** @internal */\nexport namespace OpenApiTypeCheckerBase {\n  /* -----------------------------------------------------------\n    TYPE CHECKERS\n  ----------------------------------------------------------- */\n  export const isNull = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.INull =>\n    (schema as OpenApi.IJsonSchema.INull).type === \"null\";\n\n  export const isUnknown = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IUnknown =>\n    (schema as OpenApi.IJsonSchema.IUnknown).type === undefined &&\n    !isConstant(schema) &&\n    !isOneOf(schema) &&\n    !isReference(schema);\n\n  export const isConstant = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IConstant =>\n    (schema as OpenApi.IJsonSchema.IConstant).const !== undefined;\n\n  export const isBoolean = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IBoolean =>\n    (schema as OpenApi.IJsonSchema.IBoolean).type === \"boolean\";\n\n  export const isInteger = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IInteger =>\n    (schema as OpenApi.IJsonSchema.IInteger).type === \"integer\";\n\n  export const isNumber = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.INumber =>\n    (schema as OpenApi.IJsonSchema.INumber).type === \"number\";\n\n  export const isString = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IString =>\n    (schema as OpenApi.IJsonSchema.IString).type === \"string\";\n\n  export const isArray = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IArray =>\n    (schema as OpenApi.IJsonSchema.IArray).type === \"array\" &&\n    (schema as OpenApi.IJsonSchema.IArray).items !== undefined;\n\n  export const isTuple = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.ITuple =>\n    (schema as OpenApi.IJsonSchema.ITuple).type === \"array\" &&\n    (schema as OpenApi.IJsonSchema.ITuple).prefixItems !== undefined;\n\n  export const isObject = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IObject =>\n    (schema as OpenApi.IJsonSchema.IObject).type === \"object\";\n\n  export const isReference = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IReference =>\n    (schema as any).$ref !== undefined;\n\n  export const isOneOf = (\n    schema: OpenApi.IJsonSchema,\n  ): schema is OpenApi.IJsonSchema.IOneOf =>\n    (schema as OpenApi.IJsonSchema.IOneOf).oneOf !== undefined;\n\n  export const isRecursiveReference = (props: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n  }): boolean => {\n    if (isReference(props.schema) === false) return false;\n    const current: string = props.schema.$ref.split(props.prefix)[1];\n    let counter: number = 0;\n    visit({\n      prefix: props.prefix,\n      components: props.components,\n      schema: props.schema,\n      closure: (schema) => {\n        if (isReference(schema)) {\n          const next: string = schema.$ref.split(props.prefix)[1];\n          if (current === next) ++counter;\n        }\n      },\n    });\n    return counter > 1;\n  };\n\n  /* -----------------------------------------------------------\n    OPERATORS\n  ----------------------------------------------------------- */\n  export const unreference = (props: {\n    prefix: string;\n    method: string;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<OpenApi.IJsonSchema, IOpenApiSchemaError> => {\n    const reasons: IOpenApiSchemaError.IReason[] = [];\n    const result: OpenApi.IJsonSchema | null = unreferenceSchema({\n      prefix: props.prefix,\n      refAccessor:\n        props.refAccessor ??\n        `$input.${props.prefix\n          .substring(2)\n          .split(\"/\")\n          .filter((s) => !!s.length)\n          .join(\".\")}`,\n      accessor: props.accessor ?? \"$input.schema\",\n      components: props.components,\n      schema: props.schema,\n      reasons,\n    });\n    if (result === null)\n      return {\n        success: false,\n        error: {\n          method: props.method,\n          message: `failed to unreference due to unable to find.`,\n          reasons,\n        },\n      };\n    return {\n      success: true,\n      value: result,\n    };\n  };\n\n  export const escape = (props: {\n    prefix: string;\n    method: string;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n    recursive: false | number;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<OpenApi.IJsonSchema, IOpenApiSchemaError> => {\n    const reasons: IOpenApiSchemaError.IReason[] = [];\n    const result: OpenApi.IJsonSchema | null =\n      escapeSchema({\n        ...props,\n        reasons,\n        visited: new Map(),\n        accessor: props.accessor ?? \"$input.schema\",\n        refAccessor: props.refAccessor ?? AccessorUtil.reference(props.prefix),\n      }) || null;\n    if (result === null)\n      return {\n        success: false,\n        error: {\n          method: props.method,\n          message: `failed to escape some reference type(s) due to unable to find${Number(props.recursive) === 0 ? \" or recursive relationship\" : \"\"}.`,\n          reasons,\n        },\n      };\n    return {\n      success: true,\n      value: result,\n    };\n  };\n\n  export const visit = (props: {\n    prefix: string;\n    closure: (schema: OpenApi.IJsonSchema, accessor: string) => void;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): void => {\n    const already: Set<string> = new Set();\n    const refAccessor: string =\n      props.refAccessor ?? `$input.${AccessorUtil.reference(props.prefix)}`;\n    const next = (schema: OpenApi.IJsonSchema, accessor: string): void => {\n      props.closure(schema, accessor);\n      if (isReference(schema)) {\n        const key: string = schema.$ref.split(props.prefix).pop()!;\n        if (already.has(key) === true) return;\n        already.add(key);\n        const found: OpenApi.IJsonSchema | undefined =\n          props.components.schemas?.[key];\n        if (found !== undefined)\n          next(found, `${refAccessor}[${JSON.stringify(key)}]`);\n      } else if (isOneOf(schema))\n        schema.oneOf.forEach((s, i) => next(s, `${accessor}.oneOf[${i}]`));\n      else if (isObject(schema)) {\n        for (const [key, value] of Object.entries(schema.properties ?? {}))\n          next(value, `${accessor}.properties[${JSON.stringify(key)}]`);\n        if (\n          typeof schema.additionalProperties === \"object\" &&\n          schema.additionalProperties !== null\n        )\n          next(schema.additionalProperties, `${accessor}.additionalProperties`);\n      } else if (isArray(schema)) next(schema.items, `${accessor}.items`);\n      else if (isTuple(schema)) {\n        (schema.prefixItems ?? []).forEach((s, i) =>\n          next(s, `${accessor}.prefixItems[${i}]`),\n        );\n        if (\n          typeof schema.additionalItems === \"object\" &&\n          schema.additionalItems !== null\n        )\n          next(schema.additionalItems, `${accessor}.additionalItems`);\n      }\n    };\n    next(props.schema, props.accessor ?? \"$input.schema\");\n  };\n\n  export const covers = (props: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    x: OpenApi.IJsonSchema;\n    y: OpenApi.IJsonSchema;\n  }): boolean =>\n    coverStation({\n      prefix: props.prefix,\n      components: props.components,\n      x: props.x,\n      y: props.y,\n      visited: new Map(),\n    });\n\n  const unreferenceSchema = (props: {\n    prefix: string;\n    refAccessor: string;\n    accessor: string;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n    reasons: IOpenApiSchemaError.IReason[];\n    first?: string;\n  }): OpenApi.IJsonSchema | null => {\n    if (isReference(props.schema) === false) return props.schema;\n    const key: string = props.schema.$ref.split(props.prefix).pop()!;\n    const found: OpenApi.IJsonSchema | undefined =\n      props.components.schemas?.[key];\n    if (found === undefined) {\n      props.reasons.push({\n        schema: props.schema,\n        accessor: props.accessor,\n        message: `unable to find reference type ${JSON.stringify(key)}.`,\n      });\n      return null;\n    } else if (isReference(found) === false) return found;\n    else if (props.first === key) {\n      props.reasons.push({\n        schema: props.schema,\n        accessor: props.accessor,\n        message: `recursive reference type ${JSON.stringify(key)}.`,\n      });\n      return null;\n    }\n    return unreferenceSchema({\n      ...props,\n      accessor: `${props.refAccessor}[${JSON.stringify(key)}]`,\n      first: key,\n    });\n  };\n\n  const escapeSchema = (props: {\n    components: OpenApi.IComponents;\n    prefix: string;\n    schema: OpenApi.IJsonSchema;\n    recursive: false | number;\n    visited: Map<string, number>;\n    reasons: IOpenApiSchemaError.IReason[];\n    accessor: string;\n    refAccessor: string;\n  }): OpenApi.IJsonSchema | null | undefined => {\n    if (isReference(props.schema)) {\n      // REFERENCE\n      const key: string = props.schema.$ref.split(props.prefix)[1];\n      const target: OpenApi.IJsonSchema | undefined =\n        props.components.schemas?.[key];\n      if (target === undefined) {\n        props.reasons.push({\n          schema: props.schema,\n          accessor: props.accessor,\n          message: `unable to find reference type ${JSON.stringify(key)}.`,\n        });\n        return null;\n      } else if (props.visited.has(key) === true) {\n        if (props.recursive === false) return null;\n        const depth: number = props.visited.get(key)!;\n        if (depth > props.recursive) {\n          if (props.recursive === 0) {\n            props.reasons.push({\n              schema: props.schema,\n              accessor: props.accessor,\n              message: `recursive reference type ${JSON.stringify(key)}.`,\n            });\n            return null;\n          }\n          return undefined;\n        }\n        props.visited.set(key, depth + 1);\n        const res: OpenApi.IJsonSchema | null | undefined = escapeSchema({\n          ...props,\n          schema: target,\n          accessor: `${props.refAccessor}[${JSON.stringify(key)}]`,\n        });\n        return res\n          ? {\n              ...res,\n              description: JsonDescriptionUtil.cascade({\n                prefix: props.prefix,\n                components: props.components,\n                schema: props.schema,\n                escape: true,\n              }),\n            }\n          : res;\n      } else {\n        const res: OpenApi.IJsonSchema | null | undefined = escapeSchema({\n          ...props,\n          schema: target,\n          accessor: `${props.refAccessor}[${JSON.stringify(key)}]`,\n          visited: new Map([...props.visited, [key, 1]]),\n        });\n        return res\n          ? {\n              ...res,\n              description: JsonDescriptionUtil.cascade({\n                prefix: props.prefix,\n                components: props.components,\n                schema: props.schema,\n                escape: true,\n              }),\n            }\n          : res;\n      }\n    } else if (isOneOf(props.schema)) {\n      // UNION\n      const elements: Array<OpenApi.IJsonSchema | null | undefined> =\n        props.schema.oneOf.map((s, i) =>\n          escapeSchema({\n            ...props,\n            schema: s,\n            accessor: `${props.accessor}.oneOf[${i}]`,\n          }),\n        );\n      if (elements.some((v) => v === null)) return null;\n      const filtered: OpenApi.IJsonSchema[] = elements.filter(\n        (v) => v !== undefined,\n      ) as OpenApi.IJsonSchema[];\n      if (filtered.length === 0) return undefined;\n      return {\n        ...props.schema,\n        oneOf: filtered\n          .map((v) =>\n            flatSchema({\n              prefix: props.prefix,\n              components: props.components,\n              schema: v,\n            }),\n          )\n          .flat(),\n      };\n    } else if (isObject(props.schema)) {\n      // OBJECT\n      const object: OpenApi.IJsonSchema.IObject = props.schema;\n      const properties: Array<\n        [string, OpenApi.IJsonSchema | null | undefined]\n      > = Object.entries(object.properties ?? {}).map(([k, s]) => [\n        k,\n        escapeSchema({\n          ...props,\n          schema: s,\n          visited: props.visited,\n          accessor: `${props.accessor}.properties[${JSON.stringify(k)}]`,\n        }),\n      ]);\n      const additionalProperties:\n        | OpenApi.IJsonSchema\n        | null\n        | boolean\n        | undefined = object.additionalProperties\n        ? typeof object.additionalProperties === \"object\" &&\n          object.additionalProperties !== null\n          ? escapeSchema({\n              ...props,\n              schema: object.additionalProperties,\n              accessor: `${props.accessor}.additionalProperties`,\n            })\n          : object.additionalProperties\n        : false;\n      if (\n        properties.some(([_k, v]) => v === null) ||\n        additionalProperties === null\n      )\n        return null;\n      else if (\n        properties.some(\n          ([k, v]) => v === undefined && object.required?.includes(k) === true,\n        ) === true\n      )\n        return undefined;\n      return {\n        ...object,\n        properties: Object.fromEntries(\n          properties.filter(([_k, v]) => v !== undefined) as Array<\n            [string, OpenApi.IJsonSchema]\n          >,\n        ),\n        additionalProperties: additionalProperties ?? false,\n        required:\n          object.required?.filter((k) =>\n            properties.some(([key, value]) => key === k && value !== undefined),\n          ) ?? [],\n      };\n    } else if (isTuple(props.schema)) {\n      // TUPLE\n      const elements: Array<OpenApi.IJsonSchema | null | undefined> =\n        props.schema.prefixItems.map((s, i) =>\n          escapeSchema({\n            ...props,\n            schema: s,\n            accessor: `${props.accessor}.prefixItems[${i}]`,\n          }),\n        );\n      const additionalItems: OpenApi.IJsonSchema | null | boolean | undefined =\n        props.schema.additionalItems\n          ? typeof props.schema.additionalItems === \"object\" &&\n            props.schema.additionalItems !== null\n            ? escapeSchema({\n                ...props,\n                schema: props.schema.additionalItems,\n                accessor: `${props.accessor}.additionalItems`,\n              })\n            : props.schema.additionalItems\n          : false;\n      if (elements.some((v) => v === null) || additionalItems === null)\n        return null;\n      else if (elements.some((v) => v === undefined)) return undefined;\n      return {\n        ...props.schema,\n        prefixItems: elements as OpenApi.IJsonSchema[],\n        additionalItems: additionalItems ?? false,\n      };\n    } else if (isArray(props.schema)) {\n      // ARRAY\n      const items: OpenApi.IJsonSchema | null | undefined = escapeSchema({\n        ...props,\n        schema: props.schema.items,\n        accessor: `${props.accessor}.items`,\n      });\n      if (items === null) return null;\n      else if (items === undefined)\n        return {\n          ...props.schema,\n          minItems: undefined,\n          maxItems: 0,\n          items: {},\n        };\n      return {\n        ...props.schema,\n        items: items,\n      };\n    }\n    return props.schema;\n  };\n\n  const coverStation = (p: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    visited: Map<OpenApi.IJsonSchema, Map<OpenApi.IJsonSchema, boolean>>;\n    x: OpenApi.IJsonSchema;\n    y: OpenApi.IJsonSchema;\n  }): boolean => {\n    const cache: boolean | undefined = p.visited.get(p.x)?.get(p.y);\n    if (cache !== undefined) return cache;\n\n    // FOR RECURSIVE CASE\n    const nested: Map<OpenApi.IJsonSchema, boolean> = MapUtil.take(p.visited)(\n      p.x,\n    )(() => new Map());\n    nested.set(p.y, true);\n\n    // COMPUTE IT\n    const result: boolean = coverSchema(p);\n    nested.set(p.y, result);\n    return result;\n  };\n\n  const coverSchema = (p: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    visited: Map<OpenApi.IJsonSchema, Map<OpenApi.IJsonSchema, boolean>>;\n    x: OpenApi.IJsonSchema;\n    y: OpenApi.IJsonSchema;\n  }): boolean => {\n    // CHECK EQUALITY\n    if (p.x === p.y) return true;\n    else if (isReference(p.x) && isReference(p.y) && p.x.$ref === p.y.$ref)\n      return true;\n\n    // COMPARE WITH FLATTENING\n    const alpha: OpenApi.IJsonSchema[] = flatSchema({\n      prefix: p.prefix,\n      components: p.components,\n      schema: p.x,\n    });\n    const beta: OpenApi.IJsonSchema[] = flatSchema({\n      prefix: p.prefix,\n      components: p.components,\n      schema: p.y,\n    });\n    if (alpha.some((x) => isUnknown(x))) return true;\n    else if (beta.some((x) => isUnknown(x))) return false;\n    return beta.every((b) =>\n      alpha.some((a) =>\n        coverEscapedSchema({\n          prefix: p.prefix,\n          components: p.components,\n          visited: p.visited,\n          x: a,\n          y: b,\n        }),\n      ),\n    );\n  };\n\n  const coverEscapedSchema = (p: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    visited: Map<OpenApi.IJsonSchema, Map<OpenApi.IJsonSchema, boolean>>;\n    x: OpenApi.IJsonSchema;\n    y: OpenApi.IJsonSchema;\n  }): boolean => {\n    // CHECK EQUALITY\n    if (p.x === p.y) return true;\n    else if (isUnknown(p.x)) return true;\n    else if (isUnknown(p.y)) return false;\n    else if (isNull(p.x)) return isNull(p.y);\n    // ATOMIC CASE\n    else if (isConstant(p.x)) return isConstant(p.y) && p.x.const === p.y.const;\n    else if (isBoolean(p.x))\n      return (\n        isBoolean(p.y) || (isConstant(p.y) && typeof p.y.const === \"boolean\")\n      );\n    else if (isInteger(p.x))\n      return (isInteger(p.y) || isConstant(p.y)) && coverInteger(p.x, p.y);\n    else if (isNumber(p.x))\n      return (\n        (isConstant(p.y) || isInteger(p.y) || isNumber(p.y)) &&\n        coverNumber(p.x, p.y)\n      );\n    else if (isString(p.x))\n      return (isConstant(p.y) || isString(p.y)) && coverString(p.x, p.y);\n    // INSTANCE CASE\n    else if (isArray(p.x))\n      return (\n        (isArray(p.y) || isTuple(p.y)) &&\n        coverArray({\n          prefix: p.prefix,\n          components: p.components,\n          visited: p.visited,\n          x: p.x,\n          y: p.y,\n        })\n      );\n    else if (isObject(p.x))\n      return (\n        isObject(p.y) &&\n        coverObject({\n          prefix: p.prefix,\n          components: p.components,\n          visited: p.visited,\n          x: p.x,\n          y: p.y,\n        })\n      );\n    else if (isReference(p.x)) return isReference(p.y) && p.x.$ref === p.y.$ref;\n    return false;\n  };\n\n  const coverArray = (p: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    visited: Map<OpenApi.IJsonSchema, Map<OpenApi.IJsonSchema, boolean>>;\n    x: OpenApi.IJsonSchema.IArray;\n    y: OpenApi.IJsonSchema.IArray | OpenApi.IJsonSchema.ITuple;\n  }): boolean => {\n    if (isTuple(p.y))\n      return (\n        p.y.prefixItems.every((v) =>\n          coverStation({\n            prefix: p.prefix,\n            components: p.components,\n            visited: p.visited,\n            x: p.x.items,\n            y: v,\n          }),\n        ) &&\n        (p.y.additionalItems === undefined ||\n          (typeof p.y.additionalItems === \"object\" &&\n            coverStation({\n              prefix: p.prefix,\n              components: p.components,\n              visited: p.visited,\n              x: p.x.items,\n              y: p.y.additionalItems,\n            })))\n      );\n    else if (\n      !(\n        p.x.minItems === undefined ||\n        (p.y.minItems !== undefined && p.x.minItems <= p.y.minItems)\n      )\n    )\n      return false;\n    else if (\n      !(\n        p.x.maxItems === undefined ||\n        (p.y.maxItems !== undefined && p.x.maxItems >= p.y.maxItems)\n      )\n    )\n      return false;\n    return coverStation({\n      prefix: p.prefix,\n      components: p.components,\n      visited: p.visited,\n      x: p.x.items,\n      y: p.y.items,\n    });\n  };\n\n  const coverObject = (p: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    visited: Map<OpenApi.IJsonSchema, Map<OpenApi.IJsonSchema, boolean>>;\n    x: OpenApi.IJsonSchema.IObject;\n    y: OpenApi.IJsonSchema.IObject;\n  }): boolean => {\n    if (!p.x.additionalProperties && !!p.y.additionalProperties) return false;\n    else if (\n      !!p.x.additionalProperties &&\n      !!p.y.additionalProperties &&\n      ((typeof p.x.additionalProperties === \"object\" &&\n        p.y.additionalProperties === true) ||\n        (typeof p.x.additionalProperties === \"object\" &&\n          typeof p.y.additionalProperties === \"object\" &&\n          !coverStation({\n            prefix: p.prefix,\n            components: p.components,\n            visited: p.visited,\n            x: p.x.additionalProperties,\n            y: p.y.additionalProperties,\n          })))\n    )\n      return false;\n    return Object.entries(p.y.properties ?? {}).every(([key, b]) => {\n      const a: OpenApi.IJsonSchema | undefined = p.x.properties?.[key];\n      if (a === undefined) return false;\n      else if (\n        p.x.required?.includes(key) === true &&\n        (p.y.required?.includes(key) ?? false) === false\n      )\n        return false;\n      return coverStation({\n        prefix: p.prefix,\n        components: p.components,\n        visited: p.visited,\n        x: a,\n        y: b,\n      });\n    });\n  };\n\n  const coverInteger = (\n    x: OpenApi.IJsonSchema.IInteger,\n    y: OpenApi.IJsonSchema.IConstant | OpenApi.IJsonSchema.IInteger,\n  ): boolean => {\n    if (isConstant(y))\n      return typeof y.const === \"number\" && Number.isInteger(y.const);\n    return x.type === y.type && coverNumericRange(x, y);\n  };\n\n  const coverNumber = (\n    x: OpenApi.IJsonSchema.INumber,\n    y:\n      | OpenApi.IJsonSchema.IConstant\n      | OpenApi.IJsonSchema.IInteger\n      | OpenApi.IJsonSchema.INumber,\n  ): boolean => {\n    if (isConstant(y)) return typeof y.const === \"number\";\n    return (\n      (x.type === y.type || (x.type === \"number\" && y.type === \"integer\")) &&\n      coverNumericRange(x, y)\n    );\n  };\n\n  const coverString = (\n    x: OpenApi.IJsonSchema.IString,\n    y: OpenApi.IJsonSchema.IConstant | OpenApi.IJsonSchema.IString,\n  ): boolean => {\n    if (isConstant(y)) return typeof y.const === \"string\";\n    return [\n      x.format === undefined ||\n        (y.format !== undefined && coverFormat(x.format, y.format)),\n      x.pattern === undefined || x.pattern === y.pattern,\n      x.minLength === undefined ||\n        (y.minLength !== undefined && x.minLength <= y.minLength),\n      x.maxLength === undefined ||\n        (y.maxLength !== undefined && x.maxLength >= y.maxLength),\n    ].every((v) => v);\n  };\n\n  const coverFormat = (\n    x: Required<OpenApi.IJsonSchema.IString>[\"format\"],\n    y: Required<OpenApi.IJsonSchema.IString>[\"format\"],\n  ): boolean =>\n    x === y ||\n    (x === \"idn-email\" && y === \"email\") ||\n    (x === \"idn-hostname\" && y === \"hostname\") ||\n    ([\"uri\", \"iri\"].includes(x) && y === \"url\") ||\n    (x === \"iri\" && y === \"uri\") ||\n    (x === \"iri-reference\" && y === \"uri-reference\");\n\n  const flatSchema = (props: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n  }): OpenApi.IJsonSchema[] => {\n    const schema = escapeReferenceOfFlatSchema(props);\n    if (isOneOf(schema))\n      return schema.oneOf\n        .map((v) =>\n          flatSchema({\n            prefix: props.prefix,\n            components: props.components,\n            schema: v,\n          }),\n        )\n        .flat();\n    return [schema];\n  };\n\n  const escapeReferenceOfFlatSchema = (props: {\n    prefix: string;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n  }): Exclude<OpenApi.IJsonSchema, OpenApi.IJsonSchema.IReference> => {\n    if (isReference(props.schema) === false) return props.schema;\n    const key = props.schema.$ref.replace(props.prefix, \"\");\n    const found: OpenApi.IJsonSchema | undefined = escapeReferenceOfFlatSchema({\n      prefix: props.prefix,\n      components: props.components,\n      schema: props.components.schemas?.[key] ?? {},\n    });\n    if (found === undefined)\n      throw new Error(\n        `Reference type not found: ${JSON.stringify(props.schema.$ref)}`,\n      );\n    return escapeReferenceOfFlatSchema({\n      prefix: props.prefix,\n      components: props.components,\n      schema: found,\n    });\n  };\n\n  export const coverNumericRange = (\n    x: Pick<\n      OpenApi.IJsonSchema.INumber,\n      | \"minimum\"\n      | \"maximum\"\n      | \"exclusiveMinimum\"\n      | \"exclusiveMaximum\"\n      | \"multipleOf\"\n    >,\n    y: Pick<\n      OpenApi.IJsonSchema.INumber,\n      | \"minimum\"\n      | \"maximum\"\n      | \"exclusiveMinimum\"\n      | \"exclusiveMaximum\"\n      | \"multipleOf\"\n    >,\n  ): boolean =>\n    [\n      x.minimum === undefined ||\n        (y.minimum !== undefined && x.minimum <= y.minimum) ||\n        (y.exclusiveMinimum !== undefined && x.minimum < y.exclusiveMinimum),\n      x.maximum === undefined ||\n        (y.maximum !== undefined && x.maximum >= y.maximum) ||\n        (y.exclusiveMaximum !== undefined && x.maximum > y.exclusiveMaximum),\n      x.exclusiveMinimum === undefined ||\n        (y.minimum !== undefined && x.exclusiveMinimum <= y.minimum) ||\n        (y.exclusiveMinimum !== undefined &&\n          x.exclusiveMinimum <= y.exclusiveMinimum),\n      x.exclusiveMaximum === undefined ||\n        (y.maximum !== undefined && x.exclusiveMaximum >= y.maximum) ||\n        (y.exclusiveMaximum !== undefined &&\n          x.exclusiveMaximum >= y.exclusiveMaximum),\n      x.multipleOf === undefined ||\n        (y.multipleOf !== undefined &&\n          y.multipleOf / x.multipleOf ===\n            Math.floor(y.multipleOf / x.multipleOf)),\n    ].every((v) => v);\n}\n"],"names":["OpenApiTypeCheckerBase","isNull","schema","type","isUnknown","undefined","isConstant","isOneOf","isReference","const","isBoolean","isInteger","isNumber","isString","isArray","items","isTuple","prefixItems","isObject","$ref","oneOf","isRecursiveReference","props","current","split","prefix","counter","visit","components","closure","next","unreference","reasons","result","unreferenceSchema","refAccessor","substring","filter","s","length","join","accessor","success","error","method","message","value","escape","escapeSchema","visited","Map","AccessorUtil","reference","Number","recursive","already","Set","key","pop","has","add","found","schemas","JSON","stringify","forEach","i","Object","entries","properties","additionalProperties","additionalItems","covers","coverStation","x","y","push","first","target","depth","get","set","res","description","JsonDescriptionUtil","cascade","elements","map","some","v","filtered","flatSchema","flat","object","k","_k","required","includes","fromEntries","minItems","maxItems","p","cache","nested","MapUtil","take","coverSchema","alpha","beta","every","b","a","coverEscapedSchema","coverInteger","coverNumber","coverString","coverArray","coverObject","coverNumericRange","format","coverFormat","pattern","minLength","maxLength","escapeReferenceOfFlatSchema","replace","Error","minimum","exclusiveMinimum","maximum","exclusiveMaximum","multipleOf","Math","floor"],"mappings":"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"}