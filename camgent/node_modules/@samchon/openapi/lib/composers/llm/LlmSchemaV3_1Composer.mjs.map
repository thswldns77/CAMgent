{"version":3,"file":"LlmSchemaV3_1Composer.mjs","sources":["../../../src/composers/llm/LlmSchemaV3_1Composer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3_1 } from \"../../structures/ILlmSchemaV3_1\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../structures/IResult\";\nimport { LlmTypeCheckerV3_1 } from \"../../utils/LlmTypeCheckerV3_1\";\nimport { NamingConvention } from \"../../utils/NamingConvention\";\nimport { OpenApiConstraintShifter } from \"../../utils/OpenApiConstraintShifter\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { OpenApiValidator } from \"../../utils/OpenApiValidator\";\nimport { JsonDescriptionUtil } from \"../../utils/internal/JsonDescriptionUtil\";\nimport { LlmDescriptionInverter } from \"./LlmDescriptionInverter\";\nimport { LlmParametersFinder } from \"./LlmParametersComposer\";\n\nexport namespace LlmSchemaV3_1Composer {\n  /** @internal */\n  export const IS_DEFS = true;\n\n  export const DEFAULT_CONFIG: ILlmSchemaV3_1.IConfig = {\n    reference: true,\n    constraint: true,\n  };\n\n  /* -----------------------------------------------------------\n    CONVERTERS\n  ----------------------------------------------------------- */\n  export const parameters = (props: {\n    config: ILlmSchemaV3_1.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    errors?: string[];\n    /** @internal */\n    validate?: (\n      input: OpenApi.IJsonSchema,\n      accessor: string,\n    ) => IOpenApiSchemaError.IReason[];\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<ILlmSchemaV3_1.IParameters, IOpenApiSchemaError> => {\n    const entity: IResult<OpenApi.IJsonSchema.IObject, IOpenApiSchemaError> =\n      LlmParametersFinder.parameters({\n        ...props,\n        method: \"LlmSchemaV3_1Composer.parameters\",\n      });\n    if (entity.success === false) return entity;\n\n    const $defs: Record<string, ILlmSchemaV3_1> = {};\n    const result: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> = schema({\n      ...props,\n      $defs,\n      schema: entity.value,\n    });\n    if (result.success === false) return result;\n    return {\n      success: true,\n      value: {\n        ...(result.value as ILlmSchemaV3_1.IObject),\n        additionalProperties: false,\n        $defs,\n        description: OpenApiTypeChecker.isReference(props.schema)\n          ? JsonDescriptionUtil.cascade({\n              prefix: \"#/components/schemas/\",\n              components: props.components,\n              schema: props.schema,\n              escape: true,\n            })\n          : result.value.description,\n      } satisfies ILlmSchemaV3_1.IParameters,\n    };\n  };\n\n  export const schema = (props: {\n    config: ILlmSchemaV3_1.IConfig;\n    components: OpenApi.IComponents;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: OpenApi.IJsonSchema;\n    /** @internal */\n    validate?: (\n      input: OpenApi.IJsonSchema,\n      accessor: string,\n    ) => IOpenApiSchemaError.IReason[];\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<ILlmSchemaV3_1, IOpenApiSchemaError> => {\n    const union: Array<ILlmSchemaV3_1 | null> = [];\n    const attribute: ILlmSchemaV3_1.__IAttribute = {\n      title: props.schema.title,\n      description: props.schema.description,\n      example: props.schema.example,\n      examples: props.schema.examples,\n      ...Object.fromEntries(\n        Object.entries(props.schema).filter(\n          ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n        ),\n      ),\n    };\n\n    const reasons: IOpenApiSchemaError.IReason[] = [];\n    OpenApiTypeChecker.visit({\n      closure: (next, accessor) => {\n        if (props.validate) {\n          // CUSTOM VALIDATION\n          reasons.push(...props.validate(next, accessor));\n        }\n        if (OpenApiTypeChecker.isTuple(next))\n          reasons.push({\n            schema: next,\n            accessor: accessor,\n            message: `LLM does not allow tuple type.`,\n          });\n        else if (OpenApiTypeChecker.isReference(next)) {\n          // UNABLE TO FIND MATCHED REFERENCE\n          const key = next.$ref.split(\"#/components/schemas/\")[1];\n          if (props.components.schemas?.[key] === undefined)\n            reasons.push({\n              schema: next,\n              accessor: accessor,\n              message: `unable to find reference type ${JSON.stringify(key)}.`,\n            });\n        }\n      },\n      components: props.components,\n      schema: props.schema,\n      accessor: props.accessor,\n      refAccessor: props.refAccessor,\n    });\n    if (reasons.length > 0)\n      return {\n        success: false,\n        error: {\n          method: \"LlmSchemaV3_1Composer.schema\",\n          message: \"Failed to compose LLM schema of v3.1\",\n          reasons,\n        },\n      };\n\n    const visit = (input: OpenApi.IJsonSchema, accessor: string): number => {\n      if (OpenApiTypeChecker.isOneOf(input)) {\n        // UNION TYPE\n        input.oneOf.forEach((s, i) => visit(s, `${accessor}.oneOf[${i}]`));\n        return 0;\n      } else if (OpenApiTypeChecker.isReference(input)) {\n        // REFERENCE TYPE\n        const key: string = input.$ref.split(\"#/components/schemas/\")[1];\n        const target: OpenApi.IJsonSchema | undefined =\n          props.components.schemas?.[key];\n        if (target === undefined)\n          return union.push(null); // UNREACHABLEE\n        else if (\n          // KEEP THE REFERENCE TYPE\n          props.config.reference === true ||\n          OpenApiTypeChecker.isRecursiveReference({\n            components: props.components,\n            schema: input,\n          })\n        ) {\n          const out = () =>\n            union.push({\n              ...input,\n              $ref: `#/$defs/${key}`,\n            });\n          if (props.$defs[key] !== undefined) return out();\n          props.$defs[key] = {};\n          const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n            schema({\n              config: props.config,\n              components: props.components,\n              $defs: props.$defs,\n              schema: target,\n              refAccessor: props.refAccessor,\n              accessor: `${props.refAccessor ?? \"$def\"}[${JSON.stringify(key)}]`,\n            });\n          if (converted.success === false) return union.push(null); // UNREACHABLE\n          props.$defs[key] = converted.value;\n          return out();\n        } else {\n          // DISCARD THE REFERENCE TYPE\n          const length: number = union.length;\n          visit(target, accessor);\n          if (length === union.length - 1 && union[union.length - 1] !== null)\n            union[union.length - 1] = {\n              ...union[union.length - 1]!,\n              description: JsonDescriptionUtil.cascade({\n                prefix: \"#/components/schemas/\",\n                components: props.components,\n                schema: input,\n                escape: true,\n              }),\n            };\n          else\n            attribute.description = JsonDescriptionUtil.cascade({\n              prefix: \"#/components/schemas/\",\n              components: props.components,\n              schema: input,\n              escape: true,\n            });\n          return union.length;\n        }\n      } else if (OpenApiTypeChecker.isObject(input)) {\n        // OBJECT TYPE\n        const properties: Record<string, ILlmSchemaV3_1 | null> =\n          Object.entries(input.properties ?? {}).reduce(\n            (acc, [key, value]) => {\n              const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n                schema({\n                  config: props.config,\n                  components: props.components,\n                  $defs: props.$defs,\n                  schema: value,\n                  refAccessor: props.refAccessor,\n                  accessor: `${accessor}.properties[${JSON.stringify(key)}]`,\n                });\n              acc[key] = converted.success ? converted.value : null;\n              if (converted.success === false)\n                reasons.push(...converted.error.reasons);\n              return acc;\n            },\n            {} as Record<string, ILlmSchemaV3_1 | null>,\n          );\n        if (Object.values(properties).some((v) => v === null))\n          return union.push(null);\n        const additionalProperties:\n          | ILlmSchemaV3_1\n          | boolean\n          | null\n          | undefined = (() => {\n          if (\n            typeof input.additionalProperties === \"object\" &&\n            input.additionalProperties !== null\n          ) {\n            const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n              schema({\n                config: props.config,\n                components: props.components,\n                $defs: props.$defs,\n                schema: input.additionalProperties,\n                refAccessor: props.refAccessor,\n                accessor: `${accessor}.additionalProperties`,\n              });\n            if (converted.success === false) {\n              reasons.push(...converted.error.reasons);\n              return null;\n            }\n            return converted.value;\n          }\n          return input.additionalProperties;\n        })();\n        if (additionalProperties === null) return union.push(null);\n        return union.push({\n          ...input,\n          properties: properties as Record<string, ILlmSchemaV3_1>,\n          additionalProperties,\n          required: input.required ?? [],\n        });\n      } else if (OpenApiTypeChecker.isArray(input)) {\n        const items: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> = schema({\n          config: props.config,\n          components: props.components,\n          $defs: props.$defs,\n          schema: input.items,\n          refAccessor: props.refAccessor,\n          accessor: `${accessor}.items`,\n        });\n        if (items.success === false) {\n          reasons.push(...items.error.reasons);\n          return union.push(null);\n        }\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.IArray) => x\n            : (x: ILlmSchemaV3_1.IArray) =>\n                OpenApiConstraintShifter.shiftArray(x))({\n            ...input,\n            items: items.value,\n          }),\n        );\n      } else if (OpenApiTypeChecker.isString(input))\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.IString) => x\n            : (x: ILlmSchemaV3_1.IString) =>\n                OpenApiConstraintShifter.shiftString(x))({\n            ...input,\n          }),\n        );\n      else if (\n        OpenApiTypeChecker.isNumber(input) ||\n        OpenApiTypeChecker.isInteger(input)\n      )\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.INumber | ILlmSchemaV3_1.IInteger) => x\n            : (x: ILlmSchemaV3_1.INumber | ILlmSchemaV3_1.IInteger) =>\n                OpenApiConstraintShifter.shiftNumeric(x))({\n            ...input,\n          }),\n        );\n      else if (OpenApiTypeChecker.isTuple(input))\n        return union.push(null); // UNREACHABLE\n      else return union.push({ ...input });\n    };\n    visit(props.schema, props.accessor ?? \"$input.schema\");\n\n    if (union.some((u) => u === null))\n      return {\n        success: false,\n        error: {\n          method: \"LlmSchemaV3_1Composer.schema\",\n          message: \"Failed to compose LLM schema of v3.1\",\n          reasons,\n        },\n      };\n    else if (union.length === 0)\n      return {\n        success: true,\n        value: {\n          ...attribute,\n          type: undefined,\n        },\n      };\n    else if (union.length === 1)\n      return {\n        success: true,\n        value: {\n          ...attribute,\n          ...union[0]!,\n        },\n      };\n    return {\n      success: true,\n      value: {\n        ...attribute,\n        oneOf: union.filter((u) => u !== null),\n        discriminator:\n          OpenApiTypeChecker.isOneOf(props.schema) &&\n          props.schema.discriminator !== undefined &&\n          union\n            .filter((u) => u !== null)\n            .every(\n              (e) =>\n                LlmTypeCheckerV3_1.isReference(e) ||\n                LlmTypeCheckerV3_1.isNull(e),\n            )\n            ? {\n                propertyName: props.schema.discriminator.propertyName,\n                mapping:\n                  props.schema.discriminator.mapping !== undefined\n                    ? Object.fromEntries(\n                        Object.entries(props.schema.discriminator.mapping).map(\n                          ([key, value]) => [\n                            key,\n                            `#/$defs/${value.split(\"/\").at(-1)}`,\n                          ],\n                        ),\n                      )\n                    : undefined,\n              }\n            : undefined,\n      },\n    };\n  };\n\n  /* -----------------------------------------------------------\n    SEPARATORS\n  ----------------------------------------------------------- */\n  export const separateParameters = (props: {\n    parameters: ILlmSchemaV3_1.IParameters;\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention?: (key: string, type: \"llm\" | \"human\") => string;\n    equals?: boolean;\n  }): ILlmFunction.ISeparated<\"3.1\"> => {\n    const convention =\n      props.convention ??\n      ((key, type) => `${key}.${NamingConvention.capitalize(type)}`);\n    const [llm, human] = separateObject({\n      $defs: props.parameters.$defs,\n      schema: props.parameters,\n      predicate: props.predicate,\n      convention,\n    });\n    if (llm === null || human === null)\n      return {\n        llm: (llm as ILlmSchemaV3_1.IParameters | null) ?? {\n          type: \"object\",\n          properties: {},\n          additionalProperties: false,\n          required: [],\n          $defs: {},\n        },\n        human: human as ILlmSchemaV3_1.IParameters | null,\n      };\n    const output: ILlmFunction.ISeparated<\"3.1\"> = {\n      llm: {\n        ...llm,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Llm\"),\n          ),\n        ),\n        additionalProperties: false,\n      },\n      human: {\n        ...human,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Human\"),\n          ),\n        ),\n        additionalProperties: false,\n      },\n    };\n    for (const key of Object.keys(props.parameters.$defs))\n      if (key.endsWith(\".Llm\") === false && key.endsWith(\".Human\") === false)\n        delete props.parameters.$defs[key];\n    if (Object.keys(output.llm.properties).length !== 0) {\n      const components: OpenApi.IComponents = {};\n      output.validate = OpenApiValidator.create({\n        components,\n        schema: invert({\n          components,\n          schema: output.llm,\n          $defs: output.llm.$defs,\n        }),\n        required: true,\n        equals: props.equals,\n      });\n    }\n    return output;\n  };\n\n  const separateStation = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: ILlmSchemaV3_1;\n  }): [ILlmSchemaV3_1 | null, ILlmSchemaV3_1 | null] => {\n    if (props.predicate(props.schema) === true) return [null, props.schema];\n    else if (\n      LlmTypeCheckerV3_1.isUnknown(props.schema) ||\n      LlmTypeCheckerV3_1.isOneOf(props.schema)\n    )\n      return [props.schema, null];\n    else if (LlmTypeCheckerV3_1.isObject(props.schema))\n      return separateObject({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    else if (LlmTypeCheckerV3_1.isArray(props.schema))\n      return separateArray({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    else if (LlmTypeCheckerV3_1.isReference(props.schema))\n      return separateReference({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    return [props.schema, null];\n  };\n\n  const separateArray = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: ILlmSchemaV3_1.IArray;\n  }): [ILlmSchemaV3_1.IArray | null, ILlmSchemaV3_1.IArray | null] => {\n    const [x, y] = separateStation({\n      predicate: props.predicate,\n      convention: props.convention,\n      $defs: props.$defs,\n      schema: props.schema.items,\n    });\n    return [\n      x !== null\n        ? {\n            ...props.schema,\n            items: x,\n          }\n        : null,\n      y !== null\n        ? {\n            ...props.schema,\n            items: y,\n          }\n        : null,\n    ];\n  };\n\n  const separateObject = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: ILlmSchemaV3_1.IObject;\n  }): [ILlmSchemaV3_1.IObject | null, ILlmSchemaV3_1.IObject | null] => {\n    // EMPTY OBJECT\n    if (\n      Object.keys(props.schema.properties ?? {}).length === 0 &&\n      !!props.schema.additionalProperties === false\n    )\n      return [props.schema, null];\n\n    const llm = {\n      ...props.schema,\n      properties: {} as Record<string, ILlmSchemaV3_1>,\n      additionalProperties: props.schema.additionalProperties,\n    } satisfies ILlmSchemaV3_1.IObject;\n    const human = {\n      ...props.schema,\n      properties: {} as Record<string, ILlmSchemaV3_1>,\n    } satisfies ILlmSchemaV3_1.IObject;\n\n    for (const [key, value] of Object.entries(props.schema.properties ?? {})) {\n      const [x, y] = separateStation({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: value,\n      });\n      if (x !== null) llm.properties[key] = x;\n      if (y !== null) human.properties[key] = y;\n    }\n    if (\n      typeof props.schema.additionalProperties === \"object\" &&\n      props.schema.additionalProperties !== null\n    ) {\n      const [dx, dy] = separateStation({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema.additionalProperties,\n      });\n      llm.additionalProperties = dx ?? false;\n      human.additionalProperties = dy ?? false;\n    }\n    return [\n      !!Object.keys(llm.properties).length || !!llm.additionalProperties\n        ? shrinkRequired(llm)\n        : null,\n      !!Object.keys(human.properties).length || human.additionalProperties\n        ? shrinkRequired(human)\n        : null,\n    ];\n  };\n\n  const separateReference = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: ILlmSchemaV3_1.IReference;\n  }): [ILlmSchemaV3_1.IReference | null, ILlmSchemaV3_1.IReference | null] => {\n    const key: string = props.schema.$ref.split(\"#/$defs/\")[1];\n    const humanKey: string = props.convention(key, \"human\");\n    const llmKey: string = props.convention(key, \"llm\");\n\n    // FIND EXISTING\n    if (props.$defs?.[humanKey] || props.$defs?.[llmKey])\n      return [\n        props.$defs?.[llmKey]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${llmKey}`,\n            }\n          : null,\n        props.$defs?.[humanKey]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${humanKey}`,\n            }\n          : null,\n      ];\n\n    // PRE-ASSIGNMENT\n    props.$defs![llmKey] = {};\n    props.$defs![humanKey] = {};\n\n    // DO COMPOSE\n    const schema: ILlmSchemaV3_1 = props.$defs?.[key]!;\n    const [llm, human] = separateStation({\n      predicate: props.predicate,\n      convention: props.convention,\n      $defs: props.$defs,\n      schema,\n    });\n    if (llm !== null) Object.assign(props.$defs[llmKey], llm);\n    if (human !== null) Object.assign(props.$defs[humanKey], human);\n\n    // ONLY ONE\n    if (llm === null || human === null) {\n      delete props.$defs[llmKey];\n      delete props.$defs[humanKey];\n      return llm === null ? [null, props.schema] : [props.schema, null];\n    }\n\n    // BOTH OF THEM\n    return [\n      llm !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${llmKey}`,\n          }\n        : null,\n      human !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${humanKey}`,\n          }\n        : null,\n    ];\n  };\n\n  const shrinkRequired = (\n    s: ILlmSchemaV3_1.IObject,\n  ): ILlmSchemaV3_1.IObject => {\n    if (s.required !== undefined)\n      s.required = s.required.filter(\n        (key) => s.properties?.[key] !== undefined,\n      );\n    return s;\n  };\n\n  /* -----------------------------------------------------------\n    INVERTERS\n  ----------------------------------------------------------- */\n  export const invert = (props: {\n    components: OpenApi.IComponents;\n    schema: ILlmSchemaV3_1;\n    $defs: Record<string, ILlmSchemaV3_1>;\n  }): OpenApi.IJsonSchema => {\n    const next = (schema: ILlmSchemaV3_1): OpenApi.IJsonSchema =>\n      invert({\n        components: props.components,\n        $defs: props.$defs,\n        schema,\n      });\n    if (LlmTypeCheckerV3_1.isArray(props.schema))\n      return {\n        ...props.schema,\n        ...LlmDescriptionInverter.array(props.schema.description),\n        items: next(props.schema.items),\n      };\n    else if (LlmTypeCheckerV3_1.isObject(props.schema))\n      return {\n        ...props.schema,\n        properties: props.schema.properties\n          ? Object.fromEntries(\n              Object.entries(props.schema.properties).map(([key, value]) => [\n                key,\n                next(value),\n              ]),\n            )\n          : undefined,\n        additionalProperties:\n          typeof props.schema.additionalProperties === \"object\" &&\n          props.schema.additionalProperties !== null\n            ? next(props.schema.additionalProperties)\n            : props.schema.additionalProperties,\n      };\n    else if (LlmTypeCheckerV3_1.isReference(props.schema)) {\n      const key: string = props.schema.$ref.split(\"#/$defs/\").at(-1) ?? \"\";\n      if (props.components.schemas?.[key] === undefined) {\n        props.components.schemas ??= {};\n        props.components.schemas[key] = {};\n        props.components.schemas[key] = next(props.$defs[key] ?? {});\n      }\n      return {\n        ...props.schema,\n        $ref: `#/components/schemas/${key}`,\n      };\n    } else if (LlmTypeCheckerV3_1.isOneOf(props.schema))\n      return {\n        ...props.schema,\n        oneOf: props.schema.oneOf.map(next),\n        discriminator:\n          props.schema.discriminator !== undefined\n            ? {\n                propertyName: props.schema.discriminator.propertyName,\n                mapping:\n                  props.schema.discriminator.mapping !== undefined\n                    ? Object.fromEntries(\n                        Object.entries(props.schema.discriminator.mapping).map(\n                          ([key, value]) => [\n                            key,\n                            `#/components/schemas/${value.split(\"/\").at(-1)}`,\n                          ],\n                        ),\n                      )\n                    : undefined,\n              }\n            : undefined,\n      };\n    else if (\n      LlmTypeCheckerV3_1.isInteger(props.schema) ||\n      LlmTypeCheckerV3_1.isNumber(props.schema)\n    )\n      return {\n        ...props.schema,\n        ...LlmDescriptionInverter.numeric(props.schema.description),\n      };\n    else if (LlmTypeCheckerV3_1.isString(props.schema))\n      return {\n        ...props.schema,\n        ...LlmDescriptionInverter.string(props.schema.description),\n      };\n    return props.schema;\n  };\n}\n"],"names":["LlmSchemaV3_1Composer","IS_DEFS","DEFAULT_CONFIG","reference","constraint","parameters","props","entity","LlmParametersFinder","method","success","$defs","result","schema","value","additionalProperties","description","OpenApiTypeChecker","isReference","JsonDescriptionUtil","cascade","prefix","components","escape","union","attribute","title","example","examples","Object","fromEntries","entries","filter","key","startsWith","undefined","reasons","visit","closure","next","accessor","validate","push","isTuple","message","$ref","split","schemas","JSON","stringify","refAccessor","length","error","input","isOneOf","oneOf","forEach","s","i","target","config","isRecursiveReference","out","converted","isObject","properties","reduce","acc","values","some","v","required","isArray","items","x","OpenApiConstraintShifter","shiftArray","isString","shiftString","isNumber","isInteger","shiftNumeric","u","type","discriminator","every","e","LlmTypeCheckerV3_1","isNull","propertyName","mapping","map","at","separateParameters","convention","NamingConvention","capitalize","llm","human","separateObject","predicate","output","endsWith","keys","OpenApiValidator","create","invert","equals","separateStation","isUnknown","separateArray","separateReference","y","dx","dy","shrinkRequired","humanKey","llmKey","assign","LlmDescriptionInverter","array","_a","numeric","string"],"mappings":"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"}