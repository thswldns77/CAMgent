{"version":3,"file":"GeminiSchemaComposer.mjs","sources":["../../../src/composers/llm/GeminiSchemaComposer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { OpenApiV3 } from \"../../OpenApiV3\";\nimport { OpenApiV3_1 } from \"../../OpenApiV3_1\";\nimport { IGeminiSchema } from \"../../structures/IGeminiSchema\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3 } from \"../../structures/ILlmSchemaV3\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../structures/IResult\";\nimport { LlmTypeCheckerV3 } from \"../../utils/LlmTypeCheckerV3\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { LlmParametersFinder } from \"./LlmParametersComposer\";\nimport { LlmSchemaV3Composer } from \"./LlmSchemaV3Composer\";\n\nexport namespace GeminiSchemaComposer {\n  /** @internal */\n  export const IS_DEFS = false;\n\n  export const DEFAULT_CONFIG: IGeminiSchema.IConfig = {\n    recursive: 3,\n  };\n\n  export const parameters = (props: {\n    config: IGeminiSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IGeminiSchema.IParameters, IOpenApiSchemaError> => {\n    const entity: IResult<OpenApi.IJsonSchema.IObject, IOpenApiSchemaError> =\n      LlmParametersFinder.parameters({\n        ...props,\n        method: \"GeminiSchemaComposer.parameters\",\n      });\n    if (entity.success === false) return entity;\n    return schema(props) as IResult<\n      IGeminiSchema.IParameters,\n      IOpenApiSchemaError\n    >;\n  };\n\n  export const schema = (props: {\n    config: IGeminiSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IGeminiSchema, IOpenApiSchemaError> => {\n    // TRANSFORM TO LLM SCHEMA OF V3.0\n    const result: IResult<ILlmSchemaV3, IOpenApiSchemaError> =\n      LlmSchemaV3Composer.schema({\n        ...props,\n        config: {\n          recursive: props.config.recursive,\n          constraint: false,\n        },\n        validate: (next, accessor): IOpenApiSchemaError.IReason[] => {\n          if (OpenApiTypeChecker.isObject(next)) {\n            if (!!next.additionalProperties)\n              return [\n                {\n                  schema: next,\n                  accessor: `${accessor}.additionalProperties`,\n                  message: \"Gemini does not allow additionalProperties.\",\n                },\n              ];\n          } else if (\n            OpenApiTypeChecker.isOneOf(next) &&\n            isOneOf(props.components)(next)\n          )\n            return [\n              {\n                schema: next,\n                accessor: accessor,\n                message: \"Gemini does not allow union type.\",\n              },\n            ];\n          return [];\n        },\n      });\n    if (result.success === false) return result;\n\n    // SPECIALIZATIONS\n    LlmTypeCheckerV3.visit({\n      schema: result.value,\n      closure: (v) => {\n        if (v.title !== undefined) {\n          v.description = !!v.description?.length\n            ? `${v.description}\\n\\n@title ${v.title}`\n            : `@title ${v.title}`;\n          delete v.title;\n        }\n        if (\n          LlmTypeCheckerV3.isObject(v) &&\n          v.additionalProperties !== undefined\n        ) {\n          delete (v as Partial<ILlmSchemaV3.IObject>).additionalProperties;\n        }\n      },\n    });\n\n    // DO NOT ALLOW UNION TYPE\n    return result;\n  };\n\n  export const separateParameters = (props: {\n    predicate: (schema: IGeminiSchema) => boolean;\n    parameters: IGeminiSchema.IParameters;\n    equals?: boolean;\n  }): ILlmFunction.ISeparated<\"gemini\"> => {\n    const separated: ILlmFunction.ISeparated<\"3.0\"> =\n      LlmSchemaV3Composer.separateParameters(\n        props as {\n          predicate: (schema: ILlmSchemaV3) => boolean;\n          parameters: ILlmSchemaV3.IParameters;\n          equals?: boolean;\n        },\n      );\n    return separated as any as ILlmFunction.ISeparated<\"gemini\">;\n  };\n\n  export const invert = (props: {\n    schema: IGeminiSchema;\n  }): OpenApi.IJsonSchema => LlmSchemaV3Composer.invert(props);\n}\n\nconst isOneOf =\n  (components: OpenApi.IComponents) =>\n  (schema: OpenApi.IJsonSchema): boolean => {\n    const union: OpenApiV3_1.IJsonSchema[] = [];\n    const already: Set<string> = new Set();\n    const visit = (schema: OpenApi.IJsonSchema): void => {\n      if (\n        OpenApiTypeChecker.isBoolean(schema) ||\n        OpenApiTypeChecker.isInteger(schema) ||\n        OpenApiTypeChecker.isNumber(schema) ||\n        OpenApiTypeChecker.isString(schema)\n      )\n        union.push({ ...schema });\n      else if (\n        OpenApiTypeChecker.isArray(schema) ||\n        OpenApiTypeChecker.isTuple(schema) ||\n        OpenApiTypeChecker.isObject(schema)\n      )\n        union.push(schema);\n      else if (OpenApiTypeChecker.isOneOf(schema)) schema.oneOf.forEach(visit);\n      else if (OpenApiTypeChecker.isReference(schema)) {\n        if (already.has(schema.$ref)) union.push(schema);\n        else {\n          already.add(schema.$ref);\n          const target: OpenApi.IJsonSchema | undefined =\n            components.schemas?.[schema.$ref.split(\"/\").pop()!];\n          if (target === undefined) union.push(schema);\n          else visit(target);\n        }\n      }\n    };\n    const visitConstant = (schema: OpenApi.IJsonSchema): void => {\n      const insert = (value: any): void => {\n        const matched: OpenApiV3_1.IJsonSchema.INumber | undefined = union.find(\n          (u) => (u as OpenApiV3.IJsonSchema.INumber).type === typeof value,\n        ) as OpenApiV3.IJsonSchema.INumber | undefined;\n        if (matched !== undefined) {\n          matched.enum ??= [];\n          matched.enum.push(value);\n        } else union.push({ type: typeof value as \"number\", enum: [value] });\n      };\n      if (OpenApiTypeChecker.isConstant(schema)) insert(schema.const);\n      else if (OpenApiTypeChecker.isOneOf(schema))\n        for (const u of schema.oneOf)\n          if (OpenApiTypeChecker.isConstant(u)) insert(u.const);\n    };\n    visit(schema);\n    visitConstant(schema);\n    return union.length > 1;\n  };\n"],"names":["GeminiSchemaComposer","IS_DEFS","DEFAULT_CONFIG","recursive","parameters","props","entity","LlmParametersFinder","method","success","schema","result","LlmSchemaV3Composer","config","constraint","validate","next","accessor","OpenApiTypeChecker","isObject","additionalProperties","message","isOneOf","components","LlmTypeCheckerV3","visit","value","closure","v","title","undefined","description","length","separateParameters","separated","invert","union","already","Set","isBoolean","isInteger","isNumber","isString","push","isArray","isTuple","oneOf","forEach","isReference","has","$ref","add","target","schemas","split","pop","visitConstant","insert","matched","find","u","type","enum","isConstant","const"],"mappings":"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"}