{"version":3,"file":"ChatGptSchemaComposer.mjs","sources":["../../../src/composers/llm/ChatGptSchemaComposer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { IChatGptSchema } from \"../../structures/IChatGptSchema\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3_1 } from \"../../structures/ILlmSchemaV3_1\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../structures/IResult\";\nimport { ChatGptTypeChecker } from \"../../utils/ChatGptTypeChecker\";\nimport { LlmTypeCheckerV3_1 } from \"../../utils/LlmTypeCheckerV3_1\";\nimport { NamingConvention } from \"../../utils/NamingConvention\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { OpenApiValidator } from \"../../utils/OpenApiValidator\";\nimport { JsonDescriptionUtil } from \"../../utils/internal/JsonDescriptionUtil\";\nimport { LlmDescriptionInverter } from \"./LlmDescriptionInverter\";\nimport { LlmSchemaV3_1Composer } from \"./LlmSchemaV3_1Composer\";\n\nexport namespace ChatGptSchemaComposer {\n  /** @internal */\n  export const IS_DEFS = true;\n\n  export const DEFAULT_CONFIG: IChatGptSchema.IConfig = {\n    reference: true,\n    strict: false,\n  };\n\n  /* -----------------------------------------------------------\n    CONVERTERS\n  ----------------------------------------------------------- */\n  export const parameters = (props: {\n    config: IChatGptSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IChatGptSchema.IParameters, IOpenApiSchemaError> => {\n    // polyfill\n    props.config.strict ??= false;\n\n    // validate\n    const result: IResult<ILlmSchemaV3_1.IParameters, IOpenApiSchemaError> =\n      LlmSchemaV3_1Composer.parameters({\n        ...props,\n        config: {\n          reference: props.config.reference,\n          constraint: false,\n        },\n        validate: props.config.strict === true ? validateStrict : undefined,\n      });\n    if (result.success === false) return result;\n\n    // returns with transformation\n    for (const key of Object.keys(result.value.$defs))\n      result.value.$defs[key] = transform({\n        config: props.config,\n        schema: result.value.$defs[key],\n      });\n    return {\n      success: true,\n      value: transform({\n        config: props.config,\n        schema: result.value,\n      }) as IChatGptSchema.IParameters,\n    };\n  };\n\n  export const schema = (props: {\n    config: IChatGptSchema.IConfig;\n    components: OpenApi.IComponents;\n    $defs: Record<string, IChatGptSchema>;\n    schema: OpenApi.IJsonSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IChatGptSchema, IOpenApiSchemaError> => {\n    // polyfill\n    props.config.strict ??= false;\n\n    // validate\n    const oldbie: Set<string> = new Set(Object.keys(props.$defs));\n    const result: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n      LlmSchemaV3_1Composer.schema({\n        ...props,\n        config: {\n          reference: props.config.reference,\n          constraint: false,\n        },\n        validate: props.config.strict === true ? validateStrict : undefined,\n      });\n    if (result.success === false) return result;\n\n    // returns with transformation\n    for (const key of Object.keys(props.$defs))\n      if (oldbie.has(key) === false)\n        props.$defs[key] = transform({\n          config: props.config,\n          schema: props.$defs[key],\n        });\n    return {\n      success: true,\n      value: transform({\n        config: props.config,\n        schema: result.value,\n      }),\n    };\n  };\n\n  const validateStrict = (\n    schema: OpenApi.IJsonSchema,\n    accessor: string,\n  ): IOpenApiSchemaError.IReason[] => {\n    const reasons: IOpenApiSchemaError.IReason[] = [];\n    if (OpenApiTypeChecker.isObject(schema)) {\n      if (!!schema.additionalProperties)\n        reasons.push({\n          schema: schema,\n          accessor: `${accessor}.additionalProperties`,\n          message:\n            \"ChatGPT does not allow additionalProperties in strict mode, the dynamic key typed object.\",\n        });\n      for (const key of Object.keys(schema.properties ?? {}))\n        if (schema.required?.includes(key) === false)\n          reasons.push({\n            schema: schema,\n            accessor: `${accessor}.properties.${key}`,\n            message:\n              \"ChatGPT does not allow optional properties in strict mode.\",\n          });\n    }\n    return reasons;\n  };\n\n  const transform = (props: {\n    config: IChatGptSchema.IConfig;\n    schema: ILlmSchemaV3_1;\n  }): IChatGptSchema => {\n    const union: Array<IChatGptSchema> = [];\n    const attribute: IChatGptSchema.__IAttribute = {\n      title: props.schema.title,\n      description: props.schema.description,\n      example: props.schema.example,\n      examples: props.schema.examples,\n      ...Object.fromEntries(\n        Object.entries(schema).filter(\n          ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n        ),\n      ),\n    };\n    const visit = (input: ILlmSchemaV3_1): void => {\n      if (LlmTypeCheckerV3_1.isOneOf(input)) input.oneOf.forEach(visit);\n      else if (LlmTypeCheckerV3_1.isArray(input))\n        union.push({\n          ...input,\n          items: transform({\n            config: props.config,\n            schema: input.items,\n          }),\n        });\n      else if (LlmTypeCheckerV3_1.isObject(input))\n        union.push({\n          ...input,\n          properties: Object.fromEntries(\n            Object.entries(input.properties).map(([key, value]) => [\n              key,\n              transform({\n                config: props.config,\n                schema: value,\n              }),\n            ]),\n          ),\n          additionalProperties:\n            props.config.strict === true\n              ? false\n              : typeof input.additionalProperties === \"object\" &&\n                  input.additionalProperties !== null\n                ? transform({\n                    config: props.config,\n                    schema: input.additionalProperties,\n                  })\n                : input.additionalProperties,\n          description: JsonDescriptionUtil.take(input),\n        });\n      else if (LlmTypeCheckerV3_1.isConstant(input) === false)\n        union.push(input);\n    };\n    const visitConstant = (input: ILlmSchemaV3_1): void => {\n      const insert = (value: any): void => {\n        const matched: IChatGptSchema.IString | undefined = union.find(\n          (u) =>\n            (u as IChatGptSchema.__ISignificant<any> | undefined)?.type ===\n            typeof value,\n        ) as IChatGptSchema.IString | undefined;\n        if (matched !== undefined) {\n          matched.enum ??= [];\n          matched.enum.push(value);\n        } else\n          union.push({\n            type: typeof value as \"number\",\n            enum: [value],\n          });\n      };\n      if (OpenApiTypeChecker.isConstant(input)) insert(input.const);\n      else if (OpenApiTypeChecker.isOneOf(input))\n        input.oneOf.forEach((s) => visitConstant(s as ILlmSchemaV3_1));\n    };\n    visit(props.schema);\n    visitConstant(props.schema);\n    if (union.length === 0)\n      return {\n        ...attribute,\n        type: undefined,\n      };\n    else if (union.length === 1)\n      return {\n        ...attribute,\n        ...union[0],\n        description: ChatGptTypeChecker.isReference(union[0]!)\n          ? undefined\n          : (union[0].description ?? attribute.description),\n      };\n    return {\n      ...attribute,\n      anyOf: union.map((u) => ({\n        ...u,\n        description: ChatGptTypeChecker.isReference(u)\n          ? undefined\n          : u.description,\n      })),\n      \"x-discriminator\":\n        LlmTypeCheckerV3_1.isOneOf(props.schema) &&\n        props.schema.discriminator !== undefined &&\n        props.schema.oneOf.length === union.length &&\n        union.every(\n          (e) =>\n            ChatGptTypeChecker.isReference(e) || ChatGptTypeChecker.isNull(e),\n        )\n          ? props.schema.discriminator\n          : undefined,\n    };\n  };\n\n  /* -----------------------------------------------------------\n    SEPARATORS\n  ----------------------------------------------------------- */\n  export const separateParameters = (props: {\n    parameters: IChatGptSchema.IParameters;\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention?: (key: string, type: \"llm\" | \"human\") => string;\n    equals?: boolean;\n  }): ILlmFunction.ISeparated<\"chatgpt\"> => {\n    const convention =\n      props.convention ??\n      ((key, type) => `${key}.${NamingConvention.capitalize(type)}`);\n    const [llm, human] = separateObject({\n      predicate: props.predicate,\n      convention,\n      $defs: props.parameters.$defs,\n      schema: props.parameters,\n    });\n    if (llm === null || human === null)\n      return {\n        llm: (llm as IChatGptSchema.IParameters | null) ?? {\n          type: \"object\",\n          properties: {} as Record<string, IChatGptSchema>,\n          required: [],\n          additionalProperties: false,\n          $defs: {},\n        },\n        human: human as IChatGptSchema.IParameters | null,\n      };\n    const output: ILlmFunction.ISeparated<\"chatgpt\"> = {\n      llm: {\n        ...llm,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Llm\"),\n          ),\n        ),\n        additionalProperties: false,\n      },\n      human: {\n        ...human,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Human\"),\n          ),\n        ),\n        additionalProperties: false,\n      },\n    };\n    for (const key of Object.keys(props.parameters.$defs))\n      if (key.endsWith(\".Llm\") === false && key.endsWith(\".Human\") === false)\n        delete props.parameters.$defs[key];\n    if (Object.keys(output.llm.properties).length !== 0) {\n      const components: OpenApi.IComponents = {};\n      output.validate = OpenApiValidator.create({\n        components,\n        schema: invert({\n          components,\n          schema: output.llm,\n          $defs: output.llm.$defs,\n        }),\n        required: true,\n        equals: props.equals,\n      });\n    }\n    return output;\n  };\n\n  const separateStation = (props: {\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, IChatGptSchema>;\n    schema: IChatGptSchema;\n  }): [IChatGptSchema | null, IChatGptSchema | null] => {\n    if (props.predicate(props.schema) === true) return [null, props.schema];\n    else if (\n      ChatGptTypeChecker.isUnknown(props.schema) ||\n      ChatGptTypeChecker.isAnyOf(props.schema)\n    )\n      return [props.schema, null];\n    else if (ChatGptTypeChecker.isObject(props.schema))\n      return separateObject({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    else if (ChatGptTypeChecker.isArray(props.schema))\n      return separateArray({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    else if (ChatGptTypeChecker.isReference(props.schema))\n      return separateReference({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    return [props.schema, null];\n  };\n\n  const separateArray = (props: {\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, IChatGptSchema>;\n    schema: IChatGptSchema.IArray;\n  }): [IChatGptSchema.IArray | null, IChatGptSchema.IArray | null] => {\n    const [x, y] = separateStation({\n      predicate: props.predicate,\n      convention: props.convention,\n      $defs: props.$defs,\n      schema: props.schema.items,\n    });\n    return [\n      x !== null\n        ? {\n            ...props.schema,\n            items: x,\n          }\n        : null,\n      y !== null\n        ? {\n            ...props.schema,\n            items: y,\n          }\n        : null,\n    ];\n  };\n\n  const separateObject = (props: {\n    $defs: Record<string, IChatGptSchema>;\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    schema: IChatGptSchema.IObject;\n  }): [IChatGptSchema.IObject | null, IChatGptSchema.IObject | null] => {\n    // EMPTY OBJECT\n    if (\n      Object.keys(props.schema.properties ?? {}).length === 0 &&\n      !!props.schema.additionalProperties === false\n    )\n      return [props.schema, null];\n\n    const llm = {\n      ...props.schema,\n      properties: {} as Record<string, IChatGptSchema>,\n      additionalProperties: props.schema.additionalProperties,\n    } satisfies IChatGptSchema.IObject;\n    const human = {\n      ...props.schema,\n      properties: {} as Record<string, IChatGptSchema>,\n    } satisfies IChatGptSchema.IObject;\n\n    for (const [key, value] of Object.entries(props.schema.properties ?? {})) {\n      const [x, y] = separateStation({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: value,\n      });\n      if (x !== null) llm.properties[key] = x;\n      if (y !== null) human.properties[key] = y;\n    }\n    if (\n      typeof props.schema.additionalProperties === \"object\" &&\n      props.schema.additionalProperties !== null\n    ) {\n      const [dx, dy] = separateStation({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema.additionalProperties,\n      });\n      llm.additionalProperties = dx ?? false;\n      human.additionalProperties = dy ?? false;\n    }\n    return [\n      !!Object.keys(llm.properties).length || !!llm.additionalProperties\n        ? shrinkRequired(llm)\n        : null,\n      !!Object.keys(human.properties).length || human.additionalProperties\n        ? shrinkRequired(human)\n        : null,\n    ];\n  };\n\n  const separateReference = (props: {\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, IChatGptSchema>;\n    schema: IChatGptSchema.IReference;\n  }): [IChatGptSchema.IReference | null, IChatGptSchema.IReference | null] => {\n    const key: string = props.schema.$ref.split(\"#/$defs/\")[1];\n    const humanKey: string = props.convention(key, \"human\");\n    const llmKey: string = props.convention(key, \"llm\");\n\n    // FIND EXISTING\n    if (props.$defs?.[humanKey] || props.$defs?.[llmKey])\n      return [\n        props.$defs?.[llmKey]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${llmKey}`,\n            }\n          : null,\n        props.$defs?.[humanKey]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${humanKey}`,\n            }\n          : null,\n      ];\n\n    // PRE-ASSIGNMENT\n    props.$defs![llmKey] = {};\n    props.$defs![humanKey] = {};\n\n    // DO COMPOSE\n    const schema: IChatGptSchema = props.$defs?.[key]!;\n    const [llm, human] = separateStation({\n      predicate: props.predicate,\n      convention: props.convention,\n      $defs: props.$defs,\n      schema,\n    });\n    if (llm !== null) Object.assign(props.$defs[llmKey], llm);\n    if (human !== null) Object.assign(props.$defs[humanKey], human);\n\n    // ONLY ONE\n    if (llm === null || human === null) {\n      delete props.$defs[llmKey];\n      delete props.$defs[humanKey];\n      return llm === null ? [null, props.schema] : [props.schema, null];\n    }\n\n    // BOTH OF THEM\n    return [\n      llm !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${llmKey}`,\n          }\n        : null,\n      human !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${humanKey}`,\n          }\n        : null,\n    ];\n  };\n\n  const shrinkRequired = (\n    s: IChatGptSchema.IObject,\n  ): IChatGptSchema.IObject => {\n    s.required = s.required.filter((key) => s.properties?.[key] !== undefined);\n    return s;\n  };\n\n  /* -----------------------------------------------------------\n    INVERTERS\n  ----------------------------------------------------------- */\n  export const invert = (props: {\n    components: OpenApi.IComponents;\n    schema: IChatGptSchema;\n    $defs: Record<string, IChatGptSchema>;\n  }): OpenApi.IJsonSchema => {\n    const union: OpenApi.IJsonSchema[] = [];\n    const attribute: OpenApi.IJsonSchema.__IAttribute = {\n      title: props.schema.title,\n      description: props.schema.description,\n      ...Object.fromEntries(\n        Object.entries(props.schema).filter(\n          ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n        ),\n      ),\n      example: props.schema.example,\n      examples: props.schema.examples,\n    };\n\n    const next = (schema: IChatGptSchema): OpenApi.IJsonSchema =>\n      invert({\n        components: props.components,\n        $defs: props.$defs,\n        schema,\n      });\n    const visit = (schema: IChatGptSchema): void => {\n      if (ChatGptTypeChecker.isArray(schema))\n        union.push({\n          ...schema,\n          ...LlmDescriptionInverter.array(schema.description),\n          items: next(schema.items),\n        });\n      else if (ChatGptTypeChecker.isObject(schema))\n        union.push({\n          ...schema,\n          properties: Object.fromEntries(\n            Object.entries(schema.properties).map(([key, value]) => [\n              key,\n              next(value),\n            ]),\n          ),\n          additionalProperties:\n            typeof schema.additionalProperties === \"object\" &&\n            schema.additionalProperties !== null\n              ? next(schema.additionalProperties)\n              : schema.additionalProperties,\n        });\n      else if (ChatGptTypeChecker.isAnyOf(schema)) schema.anyOf.forEach(visit);\n      else if (ChatGptTypeChecker.isReference(schema)) {\n        const key: string = schema.$ref.split(\"#/$defs/\")[1];\n        if (props.components.schemas?.[key] === undefined) {\n          props.components.schemas ??= {};\n          props.components.schemas[key] = {};\n          props.components.schemas[key] = next(props.$defs[key] ?? {});\n        }\n        union.push({\n          ...schema,\n          $ref: `#/components/schemas/${key}`,\n        });\n      } else if (ChatGptTypeChecker.isBoolean(schema))\n        if (!!schema.enum?.length)\n          schema.enum.forEach((v) =>\n            union.push({\n              const: v,\n            }),\n          );\n        else union.push(schema);\n      else if (\n        ChatGptTypeChecker.isInteger(schema) ||\n        ChatGptTypeChecker.isNumber(schema)\n      )\n        if (!!schema.enum?.length)\n          schema.enum.forEach((v) =>\n            union.push({\n              const: v,\n            }),\n          );\n        else\n          union.push({\n            ...schema,\n            ...LlmDescriptionInverter.numeric(schema.description),\n            ...{ enum: undefined },\n          });\n      else if (ChatGptTypeChecker.isString(schema))\n        if (!!schema.enum?.length)\n          schema.enum.forEach((v) =>\n            union.push({\n              const: v,\n            }),\n          );\n        else\n          union.push({\n            ...schema,\n            ...LlmDescriptionInverter.string(schema.description),\n            ...{ enum: undefined },\n          });\n      else\n        union.push({\n          ...schema,\n        });\n    };\n    visit(props.schema);\n\n    return {\n      ...attribute,\n      ...(union.length === 0\n        ? { type: undefined }\n        : union.length === 1\n          ? { ...union[0] }\n          : {\n              oneOf: union.map((u) => ({ ...u, nullable: undefined })),\n              discriminator:\n                ChatGptTypeChecker.isAnyOf(props.schema) &&\n                props.schema[\"x-discriminator\"] !== undefined\n                  ? {\n                      property: props.schema[\"x-discriminator\"],\n                      mapping:\n                        props.schema[\"x-discriminator\"].mapping !== undefined\n                          ? Object.fromEntries(\n                              Object.entries(\n                                props.schema[\"x-discriminator\"].mapping,\n                              ).map(([key, value]) => [\n                                key,\n                                `#/components/schemas/${value.split(\"/\").at(-1)}`,\n                              ]),\n                            )\n                          : undefined,\n                    }\n                  : undefined,\n            }),\n    };\n  };\n}\n"],"names":["ChatGptSchemaComposer","IS_DEFS","DEFAULT_CONFIG","reference","strict","parameters","props","_a","config","result","LlmSchemaV3_1Composer","constraint","validate","validateStrict","undefined","success","key","Object","keys","value","$defs","transform","schema","oldbie","Set","has","accessor","reasons","OpenApiTypeChecker","isObject","additionalProperties","push","message","properties","required","includes","union","attribute","title","description","example","examples","fromEntries","entries","filter","startsWith","visit","input","LlmTypeCheckerV3_1","isOneOf","oneOf","forEach","isArray","items","map","JsonDescriptionUtil","take","isConstant","visitConstant","insert","matched","find","u","type","enum","const","s","length","ChatGptTypeChecker","isReference","anyOf","discriminator","every","e","isNull","separateParameters","convention","NamingConvention","capitalize","llm","human","separateObject","predicate","output","endsWith","components","OpenApiValidator","create","invert","equals","separateStation","isUnknown","isAnyOf","separateArray","separateReference","x","y","dx","dy","shrinkRequired","$ref","split","humanKey","llmKey","assign","next","LlmDescriptionInverter","array","schemas","isBoolean","v","isInteger","isNumber","numeric","isString","string","nullable","property","mapping","at"],"mappings":"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"}