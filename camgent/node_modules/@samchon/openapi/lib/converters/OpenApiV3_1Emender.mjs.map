{"version":3,"file":"OpenApiV3_1Emender.mjs","sources":["../../src/converters/OpenApiV3_1Emender.ts"],"sourcesContent":["import { OpenApi } from \"../OpenApi\";\nimport { OpenApiV3_1 } from \"../OpenApiV3_1\";\nimport { OpenApiExclusiveEmender } from \"../utils/OpenApiExclusiveEmender\";\n\nexport namespace OpenApiV3_1Emender {\n  export const convert = (input: OpenApiV3_1.IDocument): OpenApi.IDocument => {\n    if ((input as OpenApi.IDocument)[\"x-samchon-emended-v4\"] === true)\n      return input as OpenApi.IDocument;\n    return {\n      ...input,\n      components: convertComponents(input.components ?? {}),\n      paths: input.paths\n        ? Object.fromEntries(\n            Object.entries(input.paths)\n              .filter(([_, v]) => v !== undefined)\n              .map(\n                ([key, value]) => [key, convertPathItem(input)(value)] as const,\n              ),\n          )\n        : undefined,\n      webhooks: input.webhooks\n        ? Object.fromEntries(\n            Object.entries(input.webhooks)\n              .filter(([_, v]) => v !== undefined)\n              .map(\n                ([key, value]) =>\n                  [key, convertWebhooks(input)(value)!] as const,\n              )\n              .filter(([_, value]) => value !== undefined),\n          )\n        : undefined,\n      \"x-samchon-emended-v4\": true,\n    };\n  };\n\n  /* -----------------------------------------------------------\n    OPERATORS\n  ----------------------------------------------------------- */\n  const convertWebhooks =\n    (doc: OpenApiV3_1.IDocument) =>\n    (\n      webhook:\n        | OpenApiV3_1.IPath\n        | OpenApiV3_1.IJsonSchema.IReference<`#/components/pathItems/${string}`>,\n    ): OpenApi.IPath | undefined => {\n      if (!TypeChecker.isReference(webhook))\n        return convertPathItem(doc)(webhook);\n      const found: OpenApiV3_1.IPath | undefined =\n        doc.components?.pathItems?.[webhook.$ref.split(\"/\").pop() ?? \"\"];\n      return found ? convertPathItem(doc)(found) : undefined;\n    };\n\n  const convertPathItem =\n    (doc: OpenApiV3_1.IDocument) =>\n    (pathItem: OpenApiV3_1.IPath): OpenApi.IPath => ({\n      ...(pathItem as any),\n      ...(pathItem.get\n        ? { get: convertOperation(doc)(pathItem)(pathItem.get) }\n        : undefined),\n      ...(pathItem.put\n        ? { put: convertOperation(doc)(pathItem)(pathItem.put) }\n        : undefined),\n      ...(pathItem.post\n        ? { post: convertOperation(doc)(pathItem)(pathItem.post) }\n        : undefined),\n      ...(pathItem.delete\n        ? { delete: convertOperation(doc)(pathItem)(pathItem.delete) }\n        : undefined),\n      ...(pathItem.options\n        ? { options: convertOperation(doc)(pathItem)(pathItem.options) }\n        : undefined),\n      ...(pathItem.head\n        ? { head: convertOperation(doc)(pathItem)(pathItem.head) }\n        : undefined),\n      ...(pathItem.patch\n        ? { patch: convertOperation(doc)(pathItem)(pathItem.patch) }\n        : undefined),\n      ...(pathItem.trace\n        ? { trace: convertOperation(doc)(pathItem)(pathItem.trace) }\n        : undefined),\n    });\n\n  const convertOperation =\n    (doc: OpenApiV3_1.IDocument) =>\n    (pathItem: OpenApiV3_1.IPath) =>\n    (input: OpenApiV3_1.IOperation): OpenApi.IOperation => ({\n      ...input,\n      parameters:\n        pathItem.parameters !== undefined || input.parameters !== undefined\n          ? [...(pathItem.parameters ?? []), ...(input.parameters ?? [])]\n              .map((p) => {\n                if (!TypeChecker.isReference(p))\n                  return convertParameter(doc.components ?? {})(p);\n                const found:\n                  | Omit<OpenApiV3_1.IOperation.IParameter, \"in\">\n                  | undefined = p.$ref.startsWith(\"#/components/headers/\")\n                  ? doc.components?.headers?.[p.$ref.split(\"/\").pop() ?? \"\"]\n                  : doc.components?.parameters?.[p.$ref.split(\"/\").pop() ?? \"\"];\n                return found !== undefined\n                  ? convertParameter(doc.components ?? {})({\n                      ...found,\n                      in: \"header\",\n                    })\n                  : undefined!;\n              })\n              .filter((_, v) => v !== undefined)\n          : undefined,\n      requestBody: input.requestBody\n        ? convertRequestBody(doc)(input.requestBody)\n        : undefined,\n      responses: input.responses\n        ? Object.fromEntries(\n            Object.entries(input.responses)\n              .filter(([_, v]) => v !== undefined)\n              .map(\n                ([key, value]) => [key, convertResponse(doc)(value)!] as const,\n              )\n              .filter(([_, value]) => value !== undefined),\n          )\n        : undefined,\n    });\n\n  const convertParameter =\n    (components: OpenApiV3_1.IComponents) =>\n    (\n      input: OpenApiV3_1.IOperation.IParameter,\n    ): OpenApi.IOperation.IParameter => ({\n      ...input,\n      schema: convertSchema(components)(input.schema),\n      examples: input.examples\n        ? Object.fromEntries(\n            Object.entries(input.examples)\n              .map(([key, value]) => [\n                key,\n                TypeChecker.isReference(value)\n                  ? components.examples?.[value.$ref.split(\"/\").pop() ?? \"\"]\n                  : value,\n              ])\n              .filter(([_, v]) => v !== undefined),\n          )\n        : undefined,\n    });\n\n  const convertRequestBody =\n    (doc: OpenApiV3_1.IDocument) =>\n    (\n      input:\n        | OpenApiV3_1.IOperation.IRequestBody\n        | OpenApiV3_1.IJsonSchema.IReference<`#/components/requestBodies/${string}`>,\n    ): OpenApi.IOperation.IRequestBody | undefined => {\n      if (TypeChecker.isReference(input)) {\n        const found: OpenApiV3_1.IOperation.IRequestBody | undefined =\n          doc.components?.requestBodies?.[input.$ref.split(\"/\").pop() ?? \"\"];\n        if (found === undefined) return undefined;\n        input = found;\n      }\n      return {\n        ...input,\n        content: input.content\n          ? convertContent(doc.components ?? {})(input.content)\n          : undefined,\n      };\n    };\n\n  const convertResponse =\n    (doc: OpenApiV3_1.IDocument) =>\n    (\n      input:\n        | OpenApiV3_1.IOperation.IResponse\n        | OpenApiV3_1.IJsonSchema.IReference<`#/components/responses/${string}`>,\n    ): OpenApi.IOperation.IResponse | undefined => {\n      if (TypeChecker.isReference(input)) {\n        const found: OpenApiV3_1.IOperation.IResponse | undefined =\n          doc.components?.responses?.[input.$ref.split(\"/\").pop() ?? \"\"];\n        if (found === undefined) return undefined;\n        input = found;\n      }\n      return {\n        ...input,\n        content: input.content\n          ? convertContent(doc.components ?? {})(input.content)\n          : undefined,\n        headers: input.headers\n          ? Object.fromEntries(\n              Object.entries(input.headers)\n                .filter(([_, v]) => v !== undefined)\n                .map(\n                  ([key, value]) =>\n                    [\n                      key,\n                      (() => {\n                        if (TypeChecker.isReference(value) === false)\n                          return convertParameter(doc.components ?? {})({\n                            ...value,\n                            in: \"header\",\n                          });\n                        const found:\n                          | Omit<OpenApiV3_1.IOperation.IParameter, \"in\">\n                          | undefined = value.$ref.startsWith(\n                          \"#/components/headers/\",\n                        )\n                          ? doc.components?.headers?.[\n                              value.$ref.split(\"/\").pop() ?? \"\"\n                            ]\n                          : undefined;\n                        return found !== undefined\n                          ? convertParameter(doc.components ?? {})({\n                              ...found,\n                              in: \"header\",\n                            })\n                          : undefined!;\n                      })(),\n                    ] as const,\n                )\n                .filter(([_, v]) => v !== undefined),\n            )\n          : undefined,\n      };\n    };\n\n  const convertContent =\n    (components: OpenApiV3_1.IComponents) =>\n    (\n      record: Record<string, OpenApiV3_1.IOperation.IMediaType>,\n    ): Record<string, OpenApi.IOperation.IMediaType> =>\n      Object.fromEntries(\n        Object.entries(record)\n          .filter(([_, v]) => v !== undefined)\n          .map(\n            ([key, value]) =>\n              [\n                key,\n                {\n                  ...value,\n                  schema: value.schema\n                    ? convertSchema(components)(value.schema)\n                    : undefined,\n                  examples: value.examples\n                    ? Object.fromEntries(\n                        Object.entries(value.examples)\n                          .map(([key, value]) => [\n                            key,\n                            TypeChecker.isReference(value)\n                              ? components.examples?.[\n                                  value.$ref.split(\"/\").pop() ?? \"\"\n                                ]\n                              : value,\n                          ])\n                          .filter(([_, v]) => v !== undefined),\n                      )\n                    : undefined,\n                },\n              ] as const,\n          ),\n      );\n\n  /* -----------------------------------------------------------\n    DEFINITIONS\n  ----------------------------------------------------------- */\n  export const convertComponents = (\n    input: OpenApiV3_1.IComponents,\n  ): OpenApi.IComponents => ({\n    schemas: Object.fromEntries(\n      Object.entries(input.schemas ?? {})\n        .filter(([_, v]) => v !== undefined)\n        .map(([key, value]) => [key, convertSchema(input)(value)] as const),\n    ),\n    securitySchemes: input.securitySchemes,\n  });\n\n  export const convertSchema =\n    (components: OpenApiV3_1.IComponents) =>\n    (input: OpenApiV3_1.IJsonSchema): OpenApi.IJsonSchema => {\n      const union: OpenApi.IJsonSchema[] = [];\n      const attribute: OpenApi.IJsonSchema.__IAttribute = {\n        title: input.title,\n        description: input.description,\n        ...Object.fromEntries(\n          Object.entries(input).filter(\n            ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n          ),\n        ),\n        examples: Array.isArray(input.examples)\n          ? Object.fromEntries(input.examples.map((v, i) => [`v${i}`, v]))\n          : input.examples,\n      };\n      const nullable: { value: boolean; default?: null } = {\n        value: false,\n        default: undefined,\n      };\n\n      const visit = (schema: OpenApiV3_1.IJsonSchema): void => {\n        // NULLABLE PROPERTY\n        if ((schema as OpenApiV3_1.IJsonSchema.INumber).nullable === true) {\n          nullable.value ||= true;\n          if ((schema as OpenApiV3_1.IJsonSchema.INumber).default === null)\n            nullable.default = null;\n        }\n        if (\n          Array.isArray((schema as OpenApiV3_1.IJsonSchema.INumber).enum) &&\n          (schema as OpenApiV3_1.IJsonSchema.INumber).enum?.length &&\n          (schema as OpenApiV3_1.IJsonSchema.INumber).enum?.some(\n            (e) => e === null,\n          )\n        )\n          nullable.value ||= true;\n\n        // MIXED TYPE CASE\n        if (TypeChecker.isMixed(schema)) {\n          if (schema.const !== undefined)\n            visit({\n              ...schema,\n              ...{\n                type: undefined,\n                oneOf: undefined,\n                anyOf: undefined,\n                allOf: undefined,\n                $ref: undefined,\n              },\n            });\n          if (schema.oneOf !== undefined)\n            visit({\n              ...schema,\n              ...{\n                type: undefined,\n                anyOf: undefined,\n                allOf: undefined,\n                $ref: undefined,\n              },\n            });\n          if (schema.anyOf !== undefined)\n            visit({\n              ...schema,\n              ...{\n                type: undefined,\n                oneOf: undefined,\n                allOf: undefined,\n                $ref: undefined,\n              },\n            });\n          if (schema.allOf !== undefined)\n            visit({\n              ...schema,\n              ...{\n                type: undefined,\n                oneOf: undefined,\n                anyOf: undefined,\n                $ref: undefined,\n              },\n            });\n          for (const type of schema.type)\n            if (type === \"boolean\" || type === \"number\" || type === \"string\")\n              visit({\n                ...schema,\n                ...{\n                  enum:\n                    schema.enum?.length && schema.enum.filter((e) => e !== null)\n                      ? schema.enum.filter((x) => typeof x === type)\n                      : undefined,\n                },\n                type: type as any,\n              });\n            else if (type === \"integer\")\n              visit({\n                ...schema,\n                ...{\n                  enum:\n                    schema.enum?.length && schema.enum.filter((e) => e !== null)\n                      ? schema.enum.filter(\n                          (x) =>\n                            x !== null &&\n                            typeof x === \"number\" &&\n                            Number.isInteger(x),\n                        )\n                      : undefined,\n                },\n                type: type as any,\n              });\n            else visit({ ...schema, type: type as any });\n        }\n        // UNION TYPE CASE\n        else if (TypeChecker.isOneOf(schema)) schema.oneOf.forEach(visit);\n        else if (TypeChecker.isAnyOf(schema)) schema.anyOf.forEach(visit);\n        else if (TypeChecker.isAllOf(schema))\n          if (schema.allOf.length === 1) visit(schema.allOf[0]);\n          else union.push(convertAllOfSchema(components)(schema));\n        // ATOMIC TYPE CASE (CONSIDER ENUM VALUES)\n        else if (TypeChecker.isBoolean(schema))\n          if (\n            schema.enum?.length &&\n            schema.enum.filter((e) => e !== null).length\n          )\n            for (const value of schema.enum.filter((e) => e !== null))\n              union.push({\n                const: value,\n                ...({\n                  ...schema,\n                  type: undefined as any,\n                  enum: undefined,\n                  default: undefined,\n                } satisfies OpenApiV3_1.IJsonSchema.IBoolean as any),\n              } satisfies OpenApi.IJsonSchema.IConstant);\n          else\n            union.push({\n              ...schema,\n              default: schema.default ?? undefined,\n              ...{\n                enum: undefined,\n              },\n            });\n        else if (TypeChecker.isInteger(schema) || TypeChecker.isNumber(schema))\n          if (schema.enum?.length && schema.enum.filter((e) => e !== null))\n            for (const value of schema.enum.filter((e) => e !== null))\n              union.push({\n                const: value,\n                ...({\n                  ...schema,\n                  type: undefined as any,\n                  enum: undefined,\n                  default: undefined,\n                  minimum: undefined,\n                  maximum: undefined,\n                  exclusiveMinimum: undefined,\n                  exclusiveMaximum: undefined,\n                  multipleOf: undefined,\n                } satisfies OpenApiV3_1.IJsonSchema.IInteger as any),\n              } satisfies OpenApi.IJsonSchema.IConstant);\n          else\n            union.push(\n              OpenApiExclusiveEmender.emend({\n                ...schema,\n                default: schema.default ?? undefined,\n                ...{\n                  enum: undefined,\n                },\n                exclusiveMinimum:\n                  typeof schema.exclusiveMinimum === \"boolean\"\n                    ? schema.exclusiveMinimum === true\n                      ? schema.minimum\n                      : undefined\n                    : schema.exclusiveMinimum,\n                exclusiveMaximum:\n                  typeof schema.exclusiveMaximum === \"boolean\"\n                    ? schema.exclusiveMaximum === true\n                      ? schema.maximum\n                      : undefined\n                    : schema.exclusiveMaximum,\n                minimum:\n                  schema.exclusiveMinimum === true ? undefined : schema.minimum,\n                maximum:\n                  schema.exclusiveMaximum === true ? undefined : schema.maximum,\n              }),\n            );\n        else if (TypeChecker.isString(schema))\n          if (\n            schema.enum?.length &&\n            schema.enum.filter((e) => e !== null).length\n          )\n            for (const value of schema.enum.filter((e) => e !== null))\n              union.push({\n                const: value,\n                ...({\n                  ...schema,\n                  type: undefined as any,\n                  enum: undefined,\n                  default: undefined,\n                } satisfies OpenApiV3_1.IJsonSchema.IString as any),\n              } satisfies OpenApi.IJsonSchema.IConstant);\n          else\n            union.push({\n              ...schema,\n              default: schema.default ?? undefined,\n              ...{\n                enum: undefined,\n              },\n            });\n        // ARRAY TYPE CASE (CONSIDER TUPLE)\n        else if (TypeChecker.isArray(schema)) {\n          if (Array.isArray(schema.items))\n            union.push({\n              ...schema,\n              ...{\n                items: undefined!,\n                prefixItems: schema.items.map(convertSchema(components)),\n                additionalItems:\n                  typeof schema.additionalItems === \"object\" &&\n                  schema.additionalItems !== null\n                    ? convertSchema(components)(schema.additionalItems)\n                    : schema.additionalItems,\n              },\n            } satisfies OpenApi.IJsonSchema.ITuple);\n          else if (Array.isArray(schema.prefixItems))\n            union.push({\n              ...schema,\n              ...{\n                items: undefined!,\n                prefixItems: schema.prefixItems.map(convertSchema(components)),\n                additionalItems:\n                  typeof schema.additionalItems === \"object\" &&\n                  schema.additionalItems !== null\n                    ? convertSchema(components)(schema.additionalItems)\n                    : schema.additionalItems,\n              },\n            });\n          else if (schema.items === undefined)\n            union.push({\n              ...schema,\n              ...{\n                items: undefined!,\n                prefixItems: [],\n              },\n            });\n          else\n            union.push({\n              ...schema,\n              ...{\n                items: convertSchema(components)(schema.items),\n                prefixItems: undefined,\n                additionalItems: undefined,\n              },\n            });\n        }\n        // OBJECT TYPE CASE\n        else if (TypeChecker.isObject(schema))\n          union.push({\n            ...schema,\n            ...{\n              properties: schema.properties\n                ? Object.fromEntries(\n                    Object.entries(schema.properties)\n                      .filter(([_, v]) => v !== undefined)\n                      .map(\n                        ([key, value]) =>\n                          [key, convertSchema(components)(value)] as const,\n                      ),\n                  )\n                : {},\n              additionalProperties: schema.additionalProperties\n                ? typeof schema.additionalProperties === \"object\" &&\n                  schema.additionalProperties !== null\n                  ? convertSchema(components)(schema.additionalProperties)\n                  : schema.additionalProperties\n                : undefined,\n              required: schema.required ?? [],\n            },\n          });\n        else if (TypeChecker.isReference(schema))\n          union.push({\n            ...schema,\n            ...{\n              $ref: `#/components/schemas/${schema.$ref.split(\"/\").pop()}`,\n            },\n          });\n        else if (TypeChecker.isRecursiveReference(schema))\n          union.push({\n            ...schema,\n            ...{\n              $ref: `#/components/schemas/${schema.$recursiveRef.split(\"/\").pop()}`,\n              $recursiveRef: undefined,\n            },\n          });\n        // THE OTHERS\n        else union.push(schema);\n      };\n\n      visit(input);\n      if (\n        nullable.value === true &&\n        !union.some((e) => (e as OpenApi.IJsonSchema.INull).type === \"null\")\n      )\n        union.push({\n          type: \"null\",\n          default: nullable.default,\n        });\n      return {\n        ...(union.length === 0\n          ? {\n              type: undefined,\n            }\n          : union.length === 1\n            ? {\n                ...union[0],\n              }\n            : {\n                oneOf: union.map((u) => ({\n                  ...u,\n                  nullable: undefined,\n                  $defs: undefined,\n                })),\n              }),\n        ...attribute,\n        ...{\n          nullable: undefined,\n          $defs: undefined,\n        },\n      };\n    };\n\n  const convertAllOfSchema =\n    (components: OpenApiV3_1.IComponents) =>\n    (input: OpenApiV3_1.IJsonSchema.IAllOf): OpenApi.IJsonSchema => {\n      const objects: Array<OpenApiV3_1.IJsonSchema.IObject | null> =\n        input.allOf.map((schema) => retrieveObject(components)(schema));\n      if (objects.some((obj) => obj === null))\n        return {\n          type: undefined,\n          ...{\n            allOf: undefined,\n          },\n        };\n      return {\n        ...input,\n        type: \"object\",\n        properties: Object.fromEntries(\n          objects\n            .map((o) => Object.entries(o?.properties ?? {}))\n            .flat()\n            .map(\n              ([key, value]) =>\n                [key, convertSchema(components)(value)] as const,\n            ),\n        ),\n        ...{\n          allOf: undefined,\n          required: [...new Set(objects.map((o) => o?.required ?? []).flat())],\n        },\n      };\n    };\n\n  const retrieveObject =\n    (components: OpenApiV3_1.IComponents) =>\n    (\n      input: OpenApiV3_1.IJsonSchema,\n      visited: Set<OpenApiV3_1.IJsonSchema> = new Set(),\n    ): OpenApiV3_1.IJsonSchema.IObject | null => {\n      if (TypeChecker.isObject(input))\n        return input.properties !== undefined && !input.additionalProperties\n          ? input\n          : null;\n      else if (visited.has(input)) return null;\n      else visited.add(input);\n\n      if (TypeChecker.isReference(input))\n        return retrieveObject(components)(\n          components.schemas?.[input.$ref.split(\"/\").pop() ?? \"\"] ?? {},\n          visited,\n        );\n      else if (TypeChecker.isRecursiveReference(input))\n        return retrieveObject(components)(\n          components.schemas?.[input.$recursiveRef.split(\"/\").pop() ?? \"\"] ??\n            {},\n          visited,\n        );\n      return null;\n    };\n\n  namespace TypeChecker {\n    export const isConstant = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IConstant =>\n      (schema as OpenApiV3_1.IJsonSchema.IConstant).const !== undefined;\n    export const isBoolean = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IBoolean =>\n      (schema as OpenApiV3_1.IJsonSchema.IBoolean).type === \"boolean\";\n    export const isInteger = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IInteger =>\n      (schema as OpenApiV3_1.IJsonSchema.IInteger).type === \"integer\";\n    export const isNumber = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.INumber =>\n      (schema as OpenApiV3_1.IJsonSchema.INumber).type === \"number\";\n    export const isString = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IString =>\n      (schema as OpenApiV3_1.IJsonSchema.IString).type === \"string\";\n    export const isArray = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IArray =>\n      (schema as OpenApiV3_1.IJsonSchema.IArray).type === \"array\";\n    export const isObject = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IObject =>\n      (schema as OpenApiV3_1.IJsonSchema.IObject).type === \"object\";\n    export const isReference = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IReference =>\n      (schema as OpenApiV3_1.IJsonSchema.IReference).$ref !== undefined;\n    export const isRecursiveReference = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IRecursiveReference =>\n      (schema as OpenApiV3_1.IJsonSchema.IRecursiveReference).$recursiveRef !==\n      undefined;\n    export const isAllOf = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IAllOf =>\n      (schema as OpenApiV3_1.IJsonSchema.IAllOf).allOf !== undefined;\n    export const isAnyOf = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IAnyOf =>\n      (schema as OpenApiV3_1.IJsonSchema.IAnyOf).anyOf !== undefined;\n    export const isOneOf = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IOneOf =>\n      (schema as OpenApiV3_1.IJsonSchema.IOneOf).oneOf !== undefined;\n    export const isNullOnly = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.INull =>\n      (schema as OpenApiV3_1.IJsonSchema.INull).type === \"null\";\n    export const isMixed = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IMixed =>\n      Array.isArray((schema as OpenApiV3_1.IJsonSchema.IMixed).type);\n  }\n}\n"],"names":["OpenApiV3_1Emender","convert","input","components","convertComponents","paths","Object","fromEntries","entries","filter","_","v","undefined","map","key","value","convertPathItem","webhooks","convertWebhooks","doc","webhook","TypeChecker","isReference","found","pathItems","$ref","split","pop","pathItem","get","convertOperation","put","post","delete","options","head","patch","trace","parameters","p","convertParameter","startsWith","headers","in","requestBody","convertRequestBody","responses","convertResponse","schema","convertSchema","examples","requestBodies","content","convertContent","record","schemas","securitySchemes","union","attribute","title","description","Array","isArray","i","nullable","default","visit","enum","length","some","e","isMixed","const","type","oneOf","anyOf","allOf","x","Number","isInteger","isOneOf","forEach","isAnyOf","isAllOf","push","convertAllOfSchema","isBoolean","isNumber","minimum","maximum","exclusiveMinimum","exclusiveMaximum","multipleOf","OpenApiExclusiveEmender","emend","isString","items","prefixItems","additionalItems","isObject","properties","additionalProperties","required","isRecursiveReference","$recursiveRef","u","$defs","objects","retrieveObject","obj","o","flat","Set","visited","has","add","isConstant","isNullOnly"],"mappings":"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"}