"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initialize = initialize;
const __typia_transform__validateReport = __importStar(require("typia/lib/internal/_validateReport.js"));
const typia_1 = __importDefault(require("typia"));
const AgenticaDefaultPrompt_1 = require("../constants/AgenticaDefaultPrompt");
const AgenticaSystemPrompt_1 = require("../constants/AgenticaSystemPrompt");
const events_1 = require("../factory/events");
const histories_1 = require("../factory/histories");
const ChatGptCompletionMessageUtil_1 = require("../utils/ChatGptCompletionMessageUtil");
const MPSC_1 = require("../utils/MPSC");
const StreamUtil_1 = require("../utils/StreamUtil");
const FUNCTION = {
    model: "chatgpt",
    options: {
        reference: true,
        strict: false,
        separate: null
    },
    functions: [
        {
            name: "getApiFunctions",
            parameters: {
                description: "Current Type: {@link object}",
                type: "object",
                properties: {},
                required: [],
                additionalProperties: false,
                $defs: {
                    IHttpLlmFunctionchatgpt: {
                        description: "LLM function calling schema from HTTP (OpenAPI) operation.\n\n`IHttpLlmFunction` is a data structure representing a function converted from\nthe {@link OpenApi.IOperation OpenAPI operation}, used for the LLM (Large\nLanguage Model) function calling. It's a typical RPC (Remote Procedure Call)\nstructure containing the function {@link name}, {@link parameters}, and\n{@link output return type}.\n\nIf you provide this `IHttpLlmFunction` data to the LLM provider like\n\"OpenAI\", the \"OpenAI\" will compose a function arguments by analyzing\nconversations with the user. With the LLM composed arguments, you can execute\nthe function through {@link LlmFetcher.execute} and get the result.\n\nFor reference, different between `IHttpLlmFunction` and its origin source\n{@link OpenApi.IOperation} is, `IHttpLlmFunction` has converted every type\nschema information from {@link OpenApi.IJsonSchema} to {@link ILlmSchemaV3} to\nescape {@link OpenApi.IJsonSchema.IReference reference types}, and downgrade\nthe version of the JSON schema to OpenAPI 3.0. It's because LLM function call\nfeature cannot understand both reference types and OpenAPI 3.1\nspecification.\n\nAdditionally, the properties' rule is:\n\n- `pathParameters`: Path parameters of {@link OpenApi.IOperation.parameters}\n- `query`: Query parameter of {@link IHttpMigrateRoute.query}\n- `body`: Body parameter of {@link IHttpMigrateRoute.body}\n\n```typescript\n{\n  ...pathParameters,\n  query,\n  body,\n}\n```\n\n### Description of {@link parameters} property:\n\n> List of parameter types.\n> \n> If you've configured {@link IHttpLlmApplication.IOptions.keyword} as `true`,\n> number of {@link IHttpLlmFunction.parameters} are always 1 and the first\n> parameter's type is always {@link ILlmSchemaV3.IObject}. The properties'\n> rule is:\n> \n> - `pathParameters`: Path parameters of {@link IHttpMigrateRoute.parameters}\n> - `query`: Query parameter of {@link IHttpMigrateRoute.query}\n> - `body`: Body parameter of {@link IHttpMigrateRoute.body}\n> \n> ```typescript\n> {\n>   ...pathParameters,\n>   query,\n>   body,\n> }\n> ```\n> \n> Otherwise, the parameters would be multiple, and the sequence of the\n> parameters are following below rules:\n> \n> ```typescript\n> [\n>   ...pathParameters,\n>   ...(query ? [query] : []),\n>   ...(body ? [body] : []),\n> ];\n> ```\n\n### Description of {@link separated} property:\n\n> Collection of separated parameters.\n> \n> Filled only when {@link IHttpLlmApplication.IOptions.separate} is\n> configured.",
                        type: "object",
                        properties: {
                            method: {
                                title: "HTTP method of the endpoint",
                                description: "HTTP method of the endpoint.",
                                type: "string",
                                "enum": [
                                    "get",
                                    "post",
                                    "patch",
                                    "put",
                                    "delete"
                                ]
                            },
                            path: {
                                title: "Path of the endpoint",
                                description: "Path of the endpoint.",
                                type: "string"
                            },
                            name: {
                                title: "Representative name of the function",
                                description: "Representative name of the function.\n\nThe `name` is a repsentative name identifying the function in the\n{@link IHttpLlmApplication}. The `name` value is just composed by joining\nthe {@link IHttpMigrateRoute.accessor} by underscore `_` character.\n\nHere is the composition rule of the {@link IHttpMigrateRoute.accessor}:\n\n> The `accessor` is composed with the following rules. At first, namespaces\n> are composed by static directory names in the {@link path}. Parametric\n> symbols represented by `:param` or `{param}` cannot be a part of the\n> namespace.\n\n> Instead, they would be a part of the function name. The function name is\n> composed with the {@link method HTTP method} and parametric symbols like\n> `getByParam` or `postByParam`. If there are multiple path parameters, they\n> would be concatenated by `And` like `getByParam1AndParam2`.\n\n> For refefence, if the {@link operation}'s {@link method} is `delete`, the\n> function name would be replaced to `erase` instead of `delete`. It is the\n> reason why the `delete` is a reserved keyword in many programming\n> languages.\n\n> - Example 1\n\n>   - Path: `POST /shopping/sellers/sales`\n>   - Accessor: `shopping.sellers.sales.post`\n> - Example 2\n\n>   - Endpoint: `GET\n>       /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\n>   - Accessor:\n>       `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\n\n\n@maxLength 64",
                                type: "string"
                            },
                            parameters: {
                                title: "List of parameter types",
                                $ref: "#/$defs/IChatGptSchema.IParameters"
                            },
                            separated: {
                                title: "Collection of separated parameters",
                                $ref: "#/$defs/IHttpLlmFunction.ISeparatedchatgpt"
                            },
                            output: {
                                title: "Expected return type",
                                description: "Expected return type.\n\nIf the target operation returns nothing (`void`), the `output` would be\n`undefined`.",
                                anyOf: [
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IString"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.INumber"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IInteger"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IBoolean"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IArray"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IObject"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IReference"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IAnyOf"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IUnknown"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.INull"
                                    }
                                ]
                            },
                            description: {
                                title: "Description of the function",
                                description: "Description of the function.\n\n`IHttpLlmFunction.description` is composed by below rule:\n\n1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\n2. The next paragraphs are filled with the\n   {@link OpenApi.IOperation.description}. By the way, if the first\n   paragraph of {@link OpenApi.IOperation.description} is same with the\n   {@link OpenApi.IOperation.summary}, it would not be duplicated.\n3. Parameters' descriptions are added with `@param` tag.\n4. {@link OpenApi.IOperation.security Security requirements} are added with\n   `@security` tag.\n5. Tag names are added with `@tag` tag.\n6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\n\nFor reference, the `description` is very important property to teach the\npurpose of the function to the LLM (Language Large Model), and LLM actually\ndetermines which function to call by the description.\n\nAlso, when the LLM conversates with the user, the `description` is used to\nexplain the function to the user. Therefore, the `description` property has\nthe highest priority, and you have to consider it.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the function is deprecated or not",
                                description: "Whether the function is deprecated or not.\n\nIf the `deprecated` is `true`, the function is not recommended to use.\n\nLLM (Large Language Model) may not use the deprecated function.",
                                type: "boolean"
                            },
                            tags: {
                                title: "Category tags for the function",
                                description: "Category tags for the function.\n\nSame with {@link OpenApi.IOperation.tags} indicating the category of the\nfunction.",
                                type: "array",
                                items: {
                                    type: "string"
                                }
                            }
                        },
                        required: [
                            "method",
                            "path",
                            "name",
                            "parameters"
                        ]
                    },
                    "IChatGptSchema.IParameters": {
                        description: "Type of the function parameters.\n\n`IChatGptSchema.IParameters` is a type defining a function's parameters as\na keyworded object type.\n\nIt also can be utilized for the structured output metadata.\n\n### Description of {@link $defs} property:\n\n> Collection of the named types.\n\n### Description of {@link properties} property:\n\n> Properties of the object.\n> \n> The `properties` means a list of key-value pairs of the object's regular\n> properties. The key is the name of the regular property, and the value is\n> the type schema info.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            $defs: {
                                title: "Collection of the named types",
                                $ref: "#/$defs/RecordstringIChatGptSchema"
                            },
                            additionalProperties: {
                                title: "Additional properties' info",
                                description: "Additional properties' info.\n\nThe `additionalProperties` means the type schema info of the additional\nproperties that are not listed in the {@link properties}.\n\nBy the way, it is not allowed in the parameters level.",
                                type: "boolean",
                                "enum": [
                                    false
                                ]
                            },
                            type: {
                                title: "Discriminator value of the type",
                                description: "Discriminator value of the type.",
                                type: "string",
                                "enum": [
                                    "object"
                                ]
                            },
                            properties: {
                                title: "Properties of the object",
                                $ref: "#/$defs/RecordstringIChatGptSchema"
                            },
                            required: {
                                title: "List of key values of the required properties",
                                description: "List of key values of the required properties.\n\nThe `required` means a list of the key values of the required\n{@link properties}. If some property key is not listed in the `required`\nlist, it means that property is optional. Otherwise some property key\nexists in the `required` list, it means that the property must be\nfilled.\n\nBelow is an example of the {@link properties} and `required`.\n\n```typescript\ninterface SomeObject {\n  id: string;\n  email: string;\n  name?: string;\n}\n```\n\nAs you can see, `id` and `email` {@link properties} are {@link required},\nso that they are listed in the `required` list.\n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": { \"type\": \"string\" },\n    \"email\": { \"type\": \"string\" },\n    \"name\": { \"type\": \"string\" }\n  },\n  \"required\": [\"id\", \"email\"]\n}\n```",
                                type: "array",
                                items: {
                                    type: "string"
                                }
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "$defs",
                            "additionalProperties",
                            "type",
                            "properties",
                            "required"
                        ]
                    },
                    RecordstringIChatGptSchema: {
                        description: "Construct a type with a set of properties K of type T",
                        type: "object",
                        properties: {},
                        required: [],
                        additionalProperties: {
                            $ref: "#/$defs/IChatGptSchema"
                        }
                    },
                    IChatGptSchema: {
                        title: "Type schema info of the ChatGPT",
                        description: "Type schema info of the ChatGPT.\n\n`IChatGptSchema` is a type schema info of the ChatGPT function calling.\n\n`IChatGptSchema` basically follows the JSON schema definition of the OpenAPI\nv3.1 speciifcation; {@link OpenApiV3_1.IJsonSchema}.\n\nHowever, the `IChatGptSchema` does not follow the entire specification of the\nOpenAPI v3.1. It has own specific restrictions and definitions. Here is the\nlist of how `IChatGptSchema` is different with the OpenAPI v3.1 JSON schema.\n\n- Decompose mixed type: {@link OpenApiV3_1.IJsonSchema.IMixed}\n- Resolve nullable property:\n  {@link OpenApiV3_1.IJsonSchema.__ISignificant.nullable}\n- Tuple type is banned: {@link OpenApiV3_1.IJsonSchema.ITuple.prefixItems}\n- Constant type is banned: {@link OpenApiV3_1.IJsonSchema.IConstant}\n- Merge {@link OpenApiV3_1.IJsonSchema.IOneOf} to {@link IChatGptSchema.IAnOf}\n- Merge {@link OpenApiV3_1.IJsonSchema.IAllOf} to {@link IChatGptSchema.IObject}\n- Merge {@link OpenApiV3_1.IJsonSchema.IRecursiveReference} to\n  {@link IChatGptSchema.IReference}\n- When {@link IChatGptSchema.IConfig.strict} mode\n\n  - Every object properties must be required\n  - Do not allow {@link IChatGptSchema.IObject.additionalProperties}\n\nIf compare with the {@link OpenApi.IJsonSchema}, the emended JSON schema\nspecification,\n\n- {@link IChatGptSchema.IAnyOf} instead of the {@link OpenApi.IJsonSchema.IOneOf}\n- {@link IChatGptSchema.IParameters.$defs} instead of the\n  {@link OpenApi.IJsonSchema.IComponents.schemas}\n- {@link IChatGptSchema.IString.enum} instead of the\n  {@link OpenApi.IJsonSchema.IConstant}\n- {@link IChatGptSchema.additionalProperties} is fixed to `false`\n- No tuple type {@link OpenApi.IJsonSchema.ITuple} support\n- When {@link IChatGptSchema.IConfig.strict} mode\n\n  - Every object properties must be required\n  - Do not allow {@link IChatGptSchema.IObject.additionalProperties}\n\nFor reference, if you've composed the `IChatGptSchema` type with the\n{@link IChatGptSchema.IConfig.reference} `false` option (default is `false`),\nonly the recursived named types would be archived into the\n{@link IChatGptSchema.IParameters.$defs}, and the others would be ecaped from\nthe {@link IChatGptSchema.IReference} type.\n\nAlso, OpenAI has banned below constraint properties. Instead,\n`IChatGptSchema` fills the {@link IChatGptSchema.__IAttribute.description}\nproperty with the comment text like `\"@format uuid\"`.\n\n- {@link OpenApi.IJsonSchema.INumber.minimum}\n- {@link OpenApi.IJsonSchema.INumber.maximum}\n- {@link OpenApi.IJsonSchema.INumber.multipleOf}\n- {@link OpenApi.IJsonSchema.IString.minLength}\n- {@link OpenApi.IJsonSchema.IString.maxLength}\n- {@link OpenApi.IJsonSchema.IString.format}\n- {@link OpenApi.IJsonSchema.IString.pattern}\n- {@link OpenApi.IJsonSchema.IString.contentMediaType}\n- {@link OpenApi.IJsonSchema.IString.default}\n- {@link OpenApi.IJsonSchema.IArray.minItems}\n- {@link OpenApi.IJsonSchema.IArray.maxItems}\n- {@link OpenApi.IJsonSchema.IArray.unique}\n\nAdditionally, OpenAI cannot define the `description` property to the\n{@link IChatGptSchema.IReference} type, and even does not understand the\ncapsulization to the {@link IChatGptSchema.IAnyOf} type. Therefore, the\n`description` is written to the parent object type, not the reference type.\n\n```json\n{\n  \"type\": \"object\",\n  \"description\": \"### Description of {@link something} property.\\n\\n> Hello?\",\n  \"properties\": {\n    \"something\": {\n      \"$ref\": \"#/$defs/SomeObject\"\n    }\n  }\n}\n```",
                        anyOf: [
                            {
                                $ref: "#/$defs/IChatGptSchema.IBoolean"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.IInteger"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.INumber"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.IString"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.IArray"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.IObject"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.IReference"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.IAnyOf"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.INull"
                            },
                            {
                                $ref: "#/$defs/IChatGptSchema.IUnknown"
                            }
                        ]
                    },
                    "IChatGptSchema.IBoolean": {
                        description: "Boolean type info.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            "enum": {
                                title: "Enumeration values",
                                description: "Enumeration values.",
                                type: "array",
                                items: {
                                    type: "boolean"
                                }
                            },
                            type: {
                                title: "Discriminator value of the type",
                                description: "Discriminator value of the type.",
                                type: "string",
                                "enum": [
                                    "boolean"
                                ]
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "type"
                        ]
                    },
                    Recordstringany: {
                        description: "Construct a type with a set of properties K of type T",
                        type: "object",
                        properties: {},
                        required: [],
                        additionalProperties: {}
                    },
                    "IChatGptSchema.IInteger": {
                        description: "Integer type info.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            "enum": {
                                title: "Enumeration values",
                                description: "Enumeration values.",
                                type: "array",
                                items: {
                                    type: "number"
                                }
                            },
                            type: {
                                title: "Discriminator value of the type",
                                description: "Discriminator value of the type.",
                                type: "string",
                                "enum": [
                                    "integer"
                                ]
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "type"
                        ]
                    },
                    "IChatGptSchema.INumber": {
                        description: "Number (double) type info.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            "enum": {
                                title: "Enumeration values",
                                description: "Enumeration values.",
                                type: "array",
                                items: {
                                    type: "number"
                                }
                            },
                            type: {
                                title: "Discriminator value of the type",
                                description: "Discriminator value of the type.",
                                type: "string",
                                "enum": [
                                    "number"
                                ]
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "type"
                        ]
                    },
                    "IChatGptSchema.IString": {
                        description: "String type info.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            "enum": {
                                title: "Enumeration values",
                                description: "Enumeration values.",
                                type: "array",
                                items: {
                                    type: "string"
                                }
                            },
                            type: {
                                title: "Discriminator value of the type",
                                description: "Discriminator value of the type.",
                                type: "string",
                                "enum": [
                                    "string"
                                ]
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "type"
                        ]
                    },
                    "IChatGptSchema.IArray": {
                        description: "Array type info.\n\n### Description of {@link items} property:\n\n> Items type info.\n> \n> The `items` means the type of the array elements. In other words, it is\n> the type schema info of the `T` in the TypeScript array type `Array<T>`.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            items: {
                                title: "Items type info",
                                $ref: "#/$defs/IChatGptSchema"
                            },
                            type: {
                                title: "Discriminator value of the type",
                                description: "Discriminator value of the type.",
                                type: "string",
                                "enum": [
                                    "array"
                                ]
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "items",
                            "type"
                        ]
                    },
                    "IChatGptSchema.IObject": {
                        description: "Object type info.\n\n### Description of {@link properties} property:\n\n> Properties of the object.\n> \n> The `properties` means a list of key-value pairs of the object's regular\n> properties. The key is the name of the regular property, and the value is\n> the type schema info.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            properties: {
                                title: "Properties of the object",
                                $ref: "#/$defs/RecordstringIChatGptSchema"
                            },
                            additionalProperties: {
                                title: "Additional properties' info",
                                description: "Additional properties' info.\n\nThe `additionalProperties` means the type schema info of the additional\nproperties that are not listed in the {@link properties}.\n\nBy the way, if you've configured {@link IChatGptSchema.IConfig.strict} as\n`true`, ChatGPT function calling does not support such dynamic key typed\nproperties, so the `additionalProperties` becomes always `false`.",
                                anyOf: [
                                    {
                                        type: "boolean"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IString"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.INumber"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IInteger"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IBoolean"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IArray"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IObject"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IReference"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IAnyOf"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IUnknown"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.INull"
                                    }
                                ]
                            },
                            required: {
                                title: "List of key values of the required properties",
                                description: "List of key values of the required properties.\n\nThe `required` means a list of the key values of the required\n{@link properties}. If some property key is not listed in the `required`\nlist, it means that property is optional. Otherwise some property key\nexists in the `required` list, it means that the property must be\nfilled.\n\nBelow is an example of the {@link properties} and `required`.\n\n```typescript\ninterface SomeObject {\n  id: string;\n  email: string;\n  name?: string;\n}\n```\n\nAs you can see, `id` and `email` {@link properties} are {@link required},\nso that they are listed in the `required` list.\n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": { \"type\": \"string\" },\n    \"email\": { \"type\": \"string\" },\n    \"name\": { \"type\": \"string\" }\n  },\n  \"required\": [\"id\", \"email\"]\n}\n```",
                                type: "array",
                                items: {
                                    type: "string"
                                }
                            },
                            type: {
                                title: "Discriminator value of the type",
                                description: "Discriminator value of the type.",
                                type: "string",
                                "enum": [
                                    "object"
                                ]
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "properties",
                            "required",
                            "type"
                        ]
                    },
                    "IChatGptSchema.IReference": {
                        description: "Reference type directing named schema.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            $ref: {
                                title: "Reference to the named schema",
                                description: "Reference to the named schema.\n\nThe `ref` is a reference to the named schema. Format of the `$ref` is\nfollowing the JSON Pointer specification. In the OpenAPI, the `$ref`\nstarts with `#/$defs/` which means the type is stored in the\n{@link IChatGptSchema.IParameters.$defs} object.\n\n- `#/$defs/SomeObject`\n- `#/$defs/AnotherObject`",
                                type: "string"
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "$ref"
                        ]
                    },
                    "IChatGptSchema.IAnyOf": {
                        description: "Union type.\n\n`IAnyOf` represents an union type of the TypeScript (`A | B | C`).\n\nFor reference, even though your Swagger (or OpenAPI) document has defined\n`anyOf` instead of the `oneOf`, {@link IChatGptSchema} forcibly converts it\nto `oneOf` type.\n\n### Description of {@link \"x-discriminator\"} property:\n\n> Discriminator info of the union type.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            anyOf: {
                                title: "List of the union types",
                                description: "List of the union types.",
                                type: "array",
                                items: {
                                    anyOf: [
                                        {
                                            $ref: "#/$defs/IChatGptSchema.IString"
                                        },
                                        {
                                            $ref: "#/$defs/IChatGptSchema.INumber"
                                        },
                                        {
                                            $ref: "#/$defs/IChatGptSchema.IInteger"
                                        },
                                        {
                                            $ref: "#/$defs/IChatGptSchema.IBoolean"
                                        },
                                        {
                                            $ref: "#/$defs/IChatGptSchema.IArray"
                                        },
                                        {
                                            $ref: "#/$defs/IChatGptSchema.IObject"
                                        },
                                        {
                                            $ref: "#/$defs/IChatGptSchema.IReference"
                                        },
                                        {
                                            $ref: "#/$defs/IChatGptSchema.IUnknown"
                                        },
                                        {
                                            $ref: "#/$defs/IChatGptSchema.INull"
                                        }
                                    ]
                                }
                            },
                            "x-discriminator": {
                                title: "Discriminator info of the union type",
                                $ref: "#/$defs/IChatGptSchema.IAnyOf.IDiscriminator"
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "anyOf"
                        ]
                    },
                    "IChatGptSchema.IUnknown": {
                        description: "Unknown, the `any` type.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: []
                    },
                    "IChatGptSchema.INull": {
                        description: "Null type.\n\n### Description of {@link examples} property:\n\n> List of example values as key-value pairs.",
                        type: "object",
                        properties: {
                            type: {
                                title: "Discriminator value of the type",
                                description: "Discriminator value of the type.",
                                type: "string",
                                "enum": [
                                    "null"
                                ]
                            },
                            title: {
                                title: "Title of the schema",
                                description: "Title of the schema.",
                                type: "string"
                            },
                            description: {
                                title: "Detailed description of the schema",
                                description: "Detailed description of the schema.",
                                type: "string"
                            },
                            deprecated: {
                                title: "Whether the type is deprecated or not",
                                description: "Whether the type is deprecated or not.",
                                type: "boolean"
                            },
                            example: {
                                title: "Example value",
                                description: "Example value."
                            },
                            examples: {
                                title: "List of example values as key-value pairs",
                                $ref: "#/$defs/Recordstringany"
                            }
                        },
                        required: [
                            "type"
                        ]
                    },
                    "IChatGptSchema.IAnyOf.IDiscriminator": {
                        description: "Discriminator info of the union type.\n\n### Description of {@link mapping} property:\n\n> Mapping of the discriminator value to the schema name.\n> \n> This property is valid only for {@link IReference} typed\n> {@link IAnyOf.oneof} elements. Therefore, `key` of `mapping` is the\n> discriminator value, and `value` of `mapping` is the schema name like\n> `#/components/schemas/SomeObject`.",
                        type: "object",
                        properties: {
                            propertyName: {
                                title: "Property name for the discriminator",
                                description: "Property name for the discriminator.",
                                type: "string"
                            },
                            mapping: {
                                title: "Mapping of the discriminator value to the schema name",
                                $ref: "#/$defs/Recordstringstring"
                            }
                        },
                        required: [
                            "propertyName"
                        ]
                    },
                    Recordstringstring: {
                        description: "Construct a type with a set of properties K of type T",
                        type: "object",
                        properties: {},
                        required: [],
                        additionalProperties: {
                            type: "string"
                        }
                    },
                    "IHttpLlmFunction.ISeparatedchatgpt": {
                        description: "Collection of separated parameters.\n\n### Description of {@link llm} property:\n\n> Parameters that would be composed by the LLM.\n> \n> Even though no property exists in the LLM side, the `llm` property would\n> have at least empty object type.",
                        type: "object",
                        properties: {
                            llm: {
                                title: "Parameters that would be composed by the LLM",
                                $ref: "#/$defs/IChatGptSchema.IParameters"
                            },
                            human: {
                                title: "Parameters that would be composed by the human",
                                description: "Parameters that would be composed by the human.",
                                anyOf: [
                                    {
                                        type: "null"
                                    },
                                    {
                                        $ref: "#/$defs/IChatGptSchema.IParameters"
                                    }
                                ]
                            }
                        },
                        required: [
                            "llm",
                            "human"
                        ]
                    }
                }
            },
            output: {
                type: "array",
                items: {
                    $ref: "#/$defs/IHttpLlmFunctionchatgpt"
                }
            },
            description: "Get list of API functions.\n\nIf user seems like to request some function calling except this one,\ncall this `getApiFunctions()` to get the list of candidate API functions\nprovided from this application.\n\nAlso, user just wants to list up every remote API functions that can be\ncalled from the backend server, utilize this function too.",
            validate: (() => { const _io0 = input => true; const _vo0 = (input, _path, _exceptionable = true) => true; const __is = input => "object" === typeof input && null !== input && false === Array.isArray(input) && _io0(input); let errors; let _report; return input => {
                if (false === __is(input)) {
                    errors = [];
                    _report = __typia_transform__validateReport._validateReport(errors);
                    ((input, _path, _exceptionable = true) => ("object" === typeof input && null !== input && false === Array.isArray(input) || _report(true, {
                        path: _path + "",
                        expected: "object",
                        value: input
                    })) && _vo0(input, _path + "", true) || _report(true, {
                        path: _path + "",
                        expected: "object",
                        value: input
                    }))(input, "$input", true);
                    const success = 0 === errors.length;
                    return success ? {
                        success,
                        data: input
                    } : {
                        success,
                        errors,
                        data: input
                    };
                }
                return {
                    success: true,
                    data: input
                };
            }; })()
        }
    ]
}.functions[0];
function initialize(ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        // ----
        // EXECUTE CHATGPT API
        // ----
        const completionStream = yield ctx.request("initialize", {
            messages: [
                // COMMON SYSTEM PROMPT
                {
                    role: "system",
                    content: AgenticaDefaultPrompt_1.AgenticaDefaultPrompt.write(ctx.config),
                },
                // PREVIOUS HISTORIES
                ...ctx.histories.map(histories_1.decodeHistory).flat(),
                // USER INPUT
                {
                    role: "user",
                    content: ctx.prompt.contents.map(histories_1.decodeUserMessageContent),
                },
                {
                    // SYSTEM PROMPT
                    role: "system",
                    content: (_d = (_c = (_b = (_a = ctx.config) === null || _a === void 0 ? void 0 : _a.systemPrompt) === null || _b === void 0 ? void 0 : _b.initialize) === null || _c === void 0 ? void 0 : _c.call(_b, ctx.histories)) !== null && _d !== void 0 ? _d : AgenticaSystemPrompt_1.AgenticaSystemPrompt.INITIALIZE,
                },
            ],
            // GETTER FUNCTION
            tools: [
                {
                    type: "function",
                    function: {
                        name: FUNCTION.name,
                        description: FUNCTION.description,
                        /**
                         * @TODO fix it
                         * The property and value have a type mismatch, but it works.
                         */
                        parameters: FUNCTION.parameters,
                    },
                },
            ],
            tool_choice: "auto",
            // parallel_tool_calls: false,
        });
        const textContext = [];
        const completion = yield StreamUtil_1.StreamUtil.reduce(completionStream, (accPromise, chunk) => __awaiter(this, void 0, void 0, function* () {
            const acc = yield accPromise;
            const registerContext = (choices) => {
                var _a;
                for (const choice of choices) {
                    /**
                     * @TODO fix it
                     * Sometimes, the complete message arrives along with a finish reason.
                     */
                    if (choice.finish_reason != null) {
                        (_a = textContext[choice.index]) === null || _a === void 0 ? void 0 : _a.mpsc.close();
                        continue;
                    }
                    if (choice.delta.content == null || choice.delta.content.length === 0) {
                        continue;
                    }
                    if (textContext[choice.index] != null) {
                        textContext[choice.index].content += choice.delta.content;
                        textContext[choice.index].mpsc.produce(choice.delta.content);
                        continue;
                    }
                    const mpsc = new MPSC_1.MPSC();
                    textContext[choice.index] = {
                        content: choice.delta.content,
                        mpsc,
                    };
                    mpsc.produce(choice.delta.content);
                    const event = (0, events_1.creatAssistantMessageEvent)({
                        stream: (0, StreamUtil_1.streamDefaultReaderToAsyncGenerator)(mpsc.consumer.getReader()),
                        done: () => mpsc.done(),
                        get: () => textContext[choice.index].content,
                        join: () => __awaiter(this, void 0, void 0, function* () {
                            yield mpsc.waitClosed();
                            return textContext[choice.index].content;
                        }),
                    });
                    ctx.dispatch(event);
                }
            };
            if (acc.object === "chat.completion.chunk") {
                registerContext([acc, chunk].flatMap(v => v.choices));
                return ChatGptCompletionMessageUtil_1.ChatGptCompletionMessageUtil.merge([acc, chunk]);
            }
            registerContext(chunk.choices);
            return ChatGptCompletionMessageUtil_1.ChatGptCompletionMessageUtil.accumulate(acc, chunk);
        }));
        if (completion === null) {
            throw new Error("No completion received");
        }
        // ----
        // PROCESS COMPLETION
        // ----
        if (completion.choices.some(c => c.message.tool_calls != null
            && c.message.tool_calls.some(tc => tc.type === "function" && tc.function.name === FUNCTION.name))) {
            yield ctx.initialize();
        }
    });
}
//# sourceMappingURL=initialize.js.map