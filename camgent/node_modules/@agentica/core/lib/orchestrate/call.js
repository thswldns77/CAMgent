"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.call = call;
const openapi_1 = require("@samchon/openapi");
const AgenticaConstant_1 = require("../constants/AgenticaConstant");
const AgenticaDefaultPrompt_1 = require("../constants/AgenticaDefaultPrompt");
const AgenticaSystemPrompt_1 = require("../constants/AgenticaSystemPrompt");
const isAgenticaContext_1 = require("../context/internal/isAgenticaContext");
const events_1 = require("../factory/events");
const histories_1 = require("../factory/histories");
const ChatGptCompletionMessageUtil_1 = require("../utils/ChatGptCompletionMessageUtil");
const StreamUtil_1 = require("../utils/StreamUtil");
const cancelFunctionFromContext_1 = require("./internal/cancelFunctionFromContext");
function call(ctx, operations) {
    return __awaiter(this, void 0, void 0, function* () {
        return station(ctx, operations, []);
    });
}
function station(ctx, operations, validateEvents) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g;
        // ----
        // EXECUTE CHATGPT API
        // ----
        const completionStream = yield ctx.request("call", {
            messages: [
                // COMMON SYSTEM PROMPT
                {
                    role: "system",
                    content: AgenticaDefaultPrompt_1.AgenticaDefaultPrompt.write(ctx.config),
                },
                // PREVIOUS HISTORIES
                ...ctx.histories.map(histories_1.decodeHistory).flat(),
                // USER INPUT
                {
                    role: "user",
                    content: ctx.prompt.contents.map(histories_1.decodeUserMessageContent),
                },
                // SYSTEM PROMPT
                ...(((_b = (_a = ctx.config) === null || _a === void 0 ? void 0 : _a.systemPrompt) === null || _b === void 0 ? void 0 : _b.execute) === null
                    ? []
                    : [{
                            role: "system",
                            content: (_f = (_e = (_d = (_c = ctx.config) === null || _c === void 0 ? void 0 : _c.systemPrompt) === null || _d === void 0 ? void 0 : _d.execute) === null || _e === void 0 ? void 0 : _e.call(_d, ctx.histories)) !== null && _f !== void 0 ? _f : AgenticaSystemPrompt_1.AgenticaSystemPrompt.EXECUTE,
                        }]),
            ],
            // STACKED FUNCTIONS
            tools: operations.map(s => {
                var _a;
                return ({
                    type: "function",
                    function: {
                        name: s.name,
                        description: s.function.description,
                        parameters: ("separated" in s.function
                            && s.function.separated !== undefined
                            ? ((_a = s.function.separated.llm) !== null && _a !== void 0 ? _a : {
                                type: "object",
                                properties: {},
                                required: [],
                                additionalProperties: false,
                                $defs: {},
                            })
                            : s.function.parameters),
                    },
                });
            }),
            tool_choice: "auto",
            // parallel_tool_calls: false,
        });
        // ----
        // PROCESS COMPLETION
        // ----
        const chunks = yield StreamUtil_1.StreamUtil.readAll(completionStream);
        const completion = ChatGptCompletionMessageUtil_1.ChatGptCompletionMessageUtil.merge(chunks);
        const executes = [];
        for (const choice of completion.choices) {
            for (const tc of (_g = choice.message.tool_calls) !== null && _g !== void 0 ? _g : []) {
                if (tc.type === "function") {
                    const operation = ctx.operations.flat.get(tc.function.name);
                    if (operation === undefined) {
                        continue;
                    }
                    const call = (0, events_1.createCallEvent)({
                        id: tc.id,
                        operation,
                        // @TODO add type assertion!
                        arguments: JSON.parse(tc.function.arguments),
                    });
                    if (call.operation.protocol === "http") {
                        fillHttpArguments({
                            operation: call.operation,
                            arguments: call.arguments,
                        });
                    }
                    ctx.dispatch(call);
                    const exec = yield propagate(ctx, call, 0, validateEvents);
                    ctx.dispatch(exec);
                    executes.push(exec);
                    if ((0, isAgenticaContext_1.isAgenticaContext)(ctx)) {
                        (0, cancelFunctionFromContext_1.cancelFunctionFromContext)(ctx, {
                            name: call.operation.name,
                            reason: "completed",
                        });
                    }
                }
            }
            if (choice.message.role === "assistant"
                && choice.message.content != null
                && choice.message.content.length !== 0) {
                const text = choice.message.content;
                const event = (0, events_1.creatAssistantMessageEvent)({
                    get: () => text,
                    done: () => true,
                    stream: (0, StreamUtil_1.toAsyncGenerator)(text),
                    join: () => __awaiter(this, void 0, void 0, function* () { return Promise.resolve(text); }),
                });
                ctx.dispatch(event);
            }
        }
        return executes;
    });
}
function propagate(ctx, call, retry, validateEvents) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (call.operation.protocol) {
            case "http": {
                return propagateHttp({
                    ctx,
                    operation: call.operation,
                    call,
                    retry,
                    validateEvents,
                });
            }
            case "class": {
                return propagateClass({ ctx, operation: call.operation, call, retry, validateEvents });
            }
            case "mcp": {
                return propagateMcp({ ctx, operation: call.operation, call, retry, validateEvents });
            }
            default: {
                call.operation;
                throw new Error("Unsupported protocol");
            }
        }
    });
}
function propagateHttp(props) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e;
        // ----
        // HTTP PROTOCOL
        // ----
        // NESTED VALIDATOR
        const check = props.operation.function.validate(props.call.arguments);
        if (check.success === false) {
            const ve = (0, events_1.createValidateEvent)({
                id: props.call.id,
                operation: props.call.operation,
                result: check,
            });
            props.ctx.dispatch(ve);
            props.validateEvents.push(ve);
            if (props.retry++ < ((_b = (_a = props.ctx.config) === null || _a === void 0 ? void 0 : _a.retry) !== null && _b !== void 0 ? _b : AgenticaConstant_1.AgenticaConstant.RETRY)) {
                const trial = yield correct(props.ctx, props.call, props.retry, check.errors, props.validateEvents);
                if (trial !== null) {
                    return trial;
                }
            }
        }
        try {
            // CALL HTTP API
            const response = yield executeHttpOperation(props.operation, props.call.arguments);
            // CHECK STATUS
            const success = ((response.status === 400
                || response.status === 404
                || response.status === 422)
                && props.retry++ < ((_d = (_c = props.ctx.config) === null || _c === void 0 ? void 0 : _c.retry) !== null && _d !== void 0 ? _d : AgenticaConstant_1.AgenticaConstant.RETRY)
                && typeof response.body) === false;
            // DISPATCH EVENT
            return ((_e = (success === false
                ? yield correct(props.ctx, props.call, props.retry, response.body, props.validateEvents)
                : null)) !== null && _e !== void 0 ? _e : (0, events_1.createExecuteEvent)({
                operation: props.call.operation,
                arguments: props.call.arguments,
                value: response,
            }));
        }
        catch (error) {
            // DISPATCH ERROR
            return (0, events_1.createExecuteEvent)({
                operation: props.call.operation,
                arguments: props.call.arguments,
                value: {
                    status: 500,
                    headers: {},
                    body: error instanceof Error
                        ? Object.assign(Object.assign({}, error), { name: error.name, message: error.message }) : error,
                },
            });
        }
    });
}
function propagateClass(props) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        // ----
        // CLASS FUNCTION
        // ----
        // VALIDATE FIRST
        const check = props.operation.function.validate(props.call.arguments);
        if (check.success === false) {
            const ve = (0, events_1.createValidateEvent)({
                id: props.call.id,
                operation: props.call.operation,
                result: check,
            });
            props.ctx.dispatch(ve);
            props.validateEvents.push(ve);
            return ((_c = (props.retry++ < ((_b = (_a = props.ctx.config) === null || _a === void 0 ? void 0 : _a.retry) !== null && _b !== void 0 ? _b : AgenticaConstant_1.AgenticaConstant.RETRY)
                ? yield correct(props.ctx, props.call, props.retry, check.errors, props.validateEvents)
                : null)) !== null && _c !== void 0 ? _c : (0, events_1.createExecuteEvent)({
                operation: props.call.operation,
                arguments: props.call.arguments,
                value: {
                    name: "TypeGuardError",
                    message: "Invalid arguments.",
                    errors: check.errors,
                },
            }));
        }
        // EXECUTE FUNCTION
        try {
            const value = yield executeClassOperation(props.operation, props.call.arguments);
            return (0, events_1.createExecuteEvent)({
                operation: props.call.operation,
                arguments: props.call.arguments,
                value,
            });
        }
        catch (error) {
            return (0, events_1.createExecuteEvent)({
                operation: props.call.operation,
                arguments: props.call.arguments,
                value: error instanceof Error
                    ? Object.assign(Object.assign({}, error), { name: error.name, message: error.message }) : error,
            });
        }
    });
}
function propagateMcp(props) {
    return __awaiter(this, void 0, void 0, function* () {
        // ----
        // MCP PROTOCOL
        // ----
        // @TODO: implement argument validation logic
        try {
            const value = yield executeMcpOperation(props.operation, props.call.arguments);
            return (0, events_1.createExecuteEvent)({
                operation: props.call.operation,
                arguments: props.call.arguments,
                value,
            });
        }
        catch (error) {
            return (0, events_1.createExecuteEvent)({
                operation: props.call.operation,
                arguments: props.call.arguments,
                value: error instanceof Error
                    ? Object.assign(Object.assign({}, error), { name: error.name, message: error.message }) : error,
            });
        }
    });
}
function executeHttpOperation(operation, operationArguments) {
    return __awaiter(this, void 0, void 0, function* () {
        const controllerBaseArguments = {
            connection: operation.controller.connection,
            application: operation.controller.application,
            function: operation.function,
        };
        return operation.controller.execute !== undefined
            ? operation.controller.execute(Object.assign(Object.assign({}, controllerBaseArguments), { arguments: operationArguments }))
            : openapi_1.HttpLlm.propagate(Object.assign(Object.assign({}, controllerBaseArguments), { input: operationArguments }));
    });
}
/**
 * @throws {TypeError}
 */
function executeClassOperation(operation, operationArguments) {
    return __awaiter(this, void 0, void 0, function* () {
        const execute = operation.controller.execute;
        if (typeof execute === "function") {
            return yield execute({
                application: operation.controller.application,
                function: operation.function,
                arguments: operationArguments,
            });
        }
        // As you know, it's very unstable logic.
        // But this is an intended error.
        // There are two types of errors that can occur here.
        // One is a TypeError caused by referencing an undefined value, and the other is a TypeError caused by calling something that isn't a function.
        // These errors are intentional, and any call to this function must be wrapped in a try-catch block.
        // Unless there is an overall structural improvement, this function will remain as-is.
        return execute[operation.function.name](operationArguments);
    });
}
function executeMcpOperation(operation, operationArguments) {
    return __awaiter(this, void 0, void 0, function* () {
        return operation.controller.client.callTool({
            method: operation.function.name,
            name: operation.function.name,
            arguments: operationArguments,
        }).then(v => v.content);
    });
}
function correct(ctx, call, retry, error, validateEvents) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        // ----
        // EXECUTE CHATGPT API
        // ----
        const completionStream = yield ctx.request("call", {
            messages: [
                // COMMON SYSTEM PROMPT
                {
                    role: "system",
                    content: AgenticaDefaultPrompt_1.AgenticaDefaultPrompt.write(ctx.config),
                },
                // PREVIOUS HISTORIES
                ...ctx.histories.map(histories_1.decodeHistory).flat(),
                // USER INPUT
                {
                    role: "user",
                    content: ctx.prompt.contents.map(histories_1.decodeUserMessageContent),
                },
                // TYPE CORRECTION
                ...(((_b = (_a = ctx.config) === null || _a === void 0 ? void 0 : _a.systemPrompt) === null || _b === void 0 ? void 0 : _b.execute) === null
                    ? []
                    : [{
                            role: "system",
                            content: (_f = (_e = (_d = (_c = ctx.config) === null || _c === void 0 ? void 0 : _c.systemPrompt) === null || _d === void 0 ? void 0 : _d.execute) === null || _e === void 0 ? void 0 : _e.call(_d, ctx.histories)) !== null && _f !== void 0 ? _f : AgenticaSystemPrompt_1.AgenticaSystemPrompt.EXECUTE,
                        }]),
                {
                    role: "assistant",
                    tool_calls: [
                        {
                            type: "function",
                            id: call.id,
                            function: {
                                name: call.operation.name,
                                arguments: JSON.stringify(call.arguments),
                            },
                        },
                    ],
                },
                {
                    role: "tool",
                    content: typeof error === "string" ? error : JSON.stringify(error),
                    tool_call_id: call.id,
                },
                {
                    role: "system",
                    content: (_k = (_j = (_h = (_g = ctx.config) === null || _g === void 0 ? void 0 : _g.systemPrompt) === null || _h === void 0 ? void 0 : _h.validate) === null || _j === void 0 ? void 0 : _j.call(_h, validateEvents.slice(0, -1))) !== null && _k !== void 0 ? _k : [
                        AgenticaSystemPrompt_1.AgenticaSystemPrompt.VALIDATE,
                        ...(validateEvents.length > 1
                            ? [
                                "",
                                AgenticaSystemPrompt_1.AgenticaSystemPrompt.VALIDATE_REPEATED.replace("${{HISTORICAL_ERRORS}}", JSON.stringify(validateEvents.slice(0, -1).map(e => e.result.errors))),
                            ]
                            : []),
                    ].join("\n"),
                },
            ],
            // STACK FUNCTIONS
            tools: [
                {
                    type: "function",
                    function: {
                        name: call.operation.name,
                        description: call.operation.function.description,
                        /**
                         * @TODO fix it
                         * The property and value have a type mismatch, but it works.
                         */
                        parameters: (("separated" in call.operation.function
                            && call.operation.function.separated !== undefined)
                            ? ((_m = (_l = call.operation.function.separated) === null || _l === void 0 ? void 0 : _l.llm) !== null && _m !== void 0 ? _m : {
                                $defs: {},
                                type: "object",
                                properties: {},
                                additionalProperties: false,
                                required: [],
                            })
                            : call.operation.function.parameters),
                    },
                },
            ],
            tool_choice: {
                type: "function",
                function: {
                    name: call.operation.name,
                },
            },
            // parallel_tool_calls: false,
        });
        const chunks = yield StreamUtil_1.StreamUtil.readAll(completionStream);
        const completion = ChatGptCompletionMessageUtil_1.ChatGptCompletionMessageUtil.merge(chunks);
        // ----
        // PROCESS COMPLETION
        // ----
        const toolCall = ((_p = (_o = completion.choices[0]) === null || _o === void 0 ? void 0 : _o.message.tool_calls) !== null && _p !== void 0 ? _p : []).find(tc => tc.type === "function" && tc.function.name === call.operation.name);
        if (toolCall === undefined) {
            return null;
        }
        return propagate(ctx, (0, events_1.createCallEvent)({
            id: toolCall.id,
            operation: call.operation,
            arguments: JSON.parse(toolCall.function.arguments),
        }), retry, validateEvents);
    });
}
function fillHttpArguments(props) {
    var _a;
    if (props.operation.protocol !== "http") {
        return;
    }
    const route = props.operation.function.route();
    if (route.body !== null
        && ((_a = route.operation().requestBody) === null || _a === void 0 ? void 0 : _a.required) === true
        && "body" in props.arguments
        && isObject(props.operation.function.parameters
            .$defs, props.operation.function.parameters
            .properties
            .body)) {
        props.arguments.body = {};
    }
    if (route.query !== null && "query" in props.arguments && props.arguments.query === undefined) {
        props.arguments.query = {};
    }
}
function isObject($defs, schema) {
    return (openapi_1.ChatGptTypeChecker.isObject(schema)
        || (openapi_1.ChatGptTypeChecker.isReference(schema)
            && isObject($defs, $defs[schema.$ref.split("/").at(-1)]))
        || (openapi_1.ChatGptTypeChecker.isAnyOf(schema)
            && schema.anyOf.every(schema => isObject($defs, schema)))
        || (openapi_1.LlmTypeCheckerV3_1.isOneOf(schema)
            && schema.oneOf.every(schema => isObject($defs, schema))));
}
//# sourceMappingURL=call.js.map