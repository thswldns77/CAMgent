"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatGptCompletionMessageUtil = void 0;
// import typia from "typia";
const ByteArrayUtil_1 = require("./ByteArrayUtil");
const ChatGptTokenUsageAggregator_1 = require("./ChatGptTokenUsageAggregator");
function transformCompletionChunk(source) {
    const str = source instanceof Uint8Array ? ByteArrayUtil_1.ByteArrayUtil.toUtf8(source) : source;
    const result = JSON.parse(str);
    // const valid = typia.validate<ChatCompletionChunk>(result);
    // if (valid.success === false) {
    //   console.error("Invalid ChatCompletionChunk", valid.errors);
    // }
    return result;
}
function accumulate(origin, chunk) {
    const choices = origin.choices;
    chunk.choices.forEach((choice) => {
        var _a, _b, _c, _d;
        const accChoice = choices[choice.index];
        if (accChoice != null) {
            choices[choice.index] = mergeChoice(accChoice, choice);
            return;
        }
        choices[choice.index] = {
            index: choice.index,
            finish_reason: (_a = choice.finish_reason) !== null && _a !== void 0 ? _a : null,
            logprobs: (_b = choice.logprobs) !== null && _b !== void 0 ? _b : null,
            message: {
                tool_calls: choice.delta.tool_calls !== undefined
                    ? choice.delta.tool_calls.reduce((acc, cur) => {
                        var _a, _b, _c, _d, _e;
                        acc[cur.index] = {
                            id: (_a = cur.id) !== null && _a !== void 0 ? _a : "",
                            type: "function",
                            function: {
                                name: (_c = (_b = cur.function) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : "",
                                arguments: (_e = (_d = cur.function) === null || _d === void 0 ? void 0 : _d.arguments) !== null && _e !== void 0 ? _e : "",
                            },
                        };
                        return acc;
                    }, [])
                    : undefined,
                content: (_c = choice.delta.content) !== null && _c !== void 0 ? _c : null,
                refusal: (_d = choice.delta.refusal) !== null && _d !== void 0 ? _d : null,
                role: "assistant",
            },
        };
    });
    const usage = (() => {
        if (chunk.usage == null) {
            return origin.usage;
        }
        if (origin.usage == null) {
            return chunk.usage;
        }
        return ChatGptTokenUsageAggregator_1.ChatGptTokenUsageAggregator.sum(origin.usage, chunk.usage);
    })();
    return Object.assign(Object.assign({}, origin), { choices,
        usage });
}
function merge(chunks) {
    const firstChunk = chunks[0];
    if (firstChunk === undefined) {
        throw new Error("No chunks received");
    }
    return chunks.reduce(accumulate, {
        id: firstChunk.id,
        choices: [],
        created: firstChunk.created,
        model: firstChunk.model,
        object: "chat.completion",
        usage: undefined,
        service_tier: firstChunk.service_tier,
        system_fingerprint: firstChunk.system_fingerprint,
    });
}
function mergeChoice(acc, cur) {
    var _a;
    var _b;
    if (acc.finish_reason == null && cur.finish_reason != null) {
        acc.finish_reason = cur.finish_reason;
    }
    if (acc.logprobs == null && cur.logprobs != null) {
        acc.logprobs = cur.logprobs;
    }
    if (cur.delta.content != null) {
        if (acc.message.content == null) {
            acc.message.content = cur.delta.content;
        }
        else {
            acc.message.content += cur.delta.content;
        }
    }
    if (cur.delta.refusal != null) {
        if (acc.message.refusal == null) {
            acc.message.refusal = cur.delta.refusal;
        }
        else {
            acc.message.refusal += cur.delta.refusal;
        }
    }
    if (cur.delta.tool_calls != null) {
        (_a = (_b = acc.message).tool_calls) !== null && _a !== void 0 ? _a : (_b.tool_calls = []);
        const toolCalls = acc.message.tool_calls;
        cur.delta.tool_calls.forEach((toolCall) => {
            var _a, _b, _c, _d, _e;
            const existingToolCall = toolCalls[toolCall.index];
            if (existingToolCall != null) {
                toolCalls[toolCall.index] = mergeToolCalls(existingToolCall, toolCall);
                return;
            }
            toolCalls[toolCall.index] = {
                id: (_a = toolCall.id) !== null && _a !== void 0 ? _a : "",
                type: "function",
                function: {
                    name: (_c = (_b = toolCall.function) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : "",
                    arguments: (_e = (_d = toolCall.function) === null || _d === void 0 ? void 0 : _d.arguments) !== null && _e !== void 0 ? _e : "",
                },
            };
        });
    }
    return acc;
}
function mergeToolCalls(acc, cur) {
    var _a, _b, _c;
    if (cur.function != null) {
        acc.function.arguments += (_a = cur.function.arguments) !== null && _a !== void 0 ? _a : "";
        acc.function.name += (_b = cur.function.name) !== null && _b !== void 0 ? _b : "";
    }
    acc.id += (_c = cur.id) !== null && _c !== void 0 ? _c : "";
    return acc;
}
exports.ChatGptCompletionMessageUtil = {
    transformCompletionChunk,
    accumulate,
    merge,
    mergeChoice,
    mergeToolCalls,
};
//# sourceMappingURL=ChatGptCompletionMessageUtil.js.map