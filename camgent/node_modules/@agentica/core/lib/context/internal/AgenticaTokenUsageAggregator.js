"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgenticaTokenUsageAggregator = void 0;
exports.aggregate = aggregate;
function aggregate(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    // ----
    // COMPONENT
    // ----
    const component = props.usage[props.kind];
    // TOTAL
    component.total += props.completionUsage.total_tokens;
    // PROMPT
    component.input.total += props.completionUsage.prompt_tokens;
    component.input.total
        += (_b = (_a = props.completionUsage.prompt_tokens_details) === null || _a === void 0 ? void 0 : _a.audio_tokens) !== null && _b !== void 0 ? _b : 0;
    component.input.cached
        += (_d = (_c = props.completionUsage.prompt_tokens_details) === null || _c === void 0 ? void 0 : _c.cached_tokens) !== null && _d !== void 0 ? _d : 0;
    // COMPLETION
    component.output.total += props.completionUsage.completion_tokens;
    component.output.accepted_prediction
        += (_f = (_e = props.completionUsage.completion_tokens_details) === null || _e === void 0 ? void 0 : _e.accepted_prediction_tokens) !== null && _f !== void 0 ? _f : 0;
    component.output.reasoning
        += (_h = (_g = props.completionUsage.completion_tokens_details) === null || _g === void 0 ? void 0 : _g.reasoning_tokens) !== null && _h !== void 0 ? _h : 0;
    component.output.rejected_prediction
        += (_k = (_j = props.completionUsage.completion_tokens_details) === null || _j === void 0 ? void 0 : _j.rejected_prediction_tokens) !== null && _k !== void 0 ? _k : 0;
    // ----
    // RE-AGGREGATE
    // ----
    const sum = (getter) => Object.entries(props.usage)
        .filter(([key]) => key !== "aggregate")
        .map(([, comp]) => getter(comp))
        .reduce((a, b) => a + b, 0);
    const aggregate = props.usage.aggregate;
    aggregate.total = sum(comp => comp.total);
    aggregate.input.total = sum(comp => comp.input.total);
    aggregate.input.cached = sum(comp => comp.input.cached);
    aggregate.output.total = sum(comp => comp.output.total);
    aggregate.output.reasoning = sum(comp => comp.output.reasoning);
    aggregate.output.accepted_prediction = sum(comp => comp.output.accepted_prediction);
    aggregate.output.rejected_prediction = sum(comp => comp.output.rejected_prediction);
}
exports.AgenticaTokenUsageAggregator = {
    aggregate,
};
//# sourceMappingURL=AgenticaTokenUsageAggregator.js.map